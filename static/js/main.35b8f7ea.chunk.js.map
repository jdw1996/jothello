{"version":3,"sources":["index.tsx"],"names":["Marker","markerToStr","marker","HUMAN","BOT","getMarker","isHuman","coordToString","coord","stringToCoord","key","ret","split","map","Number","length","Error","cloneBoardArray","board","row","newRow","sc","push","MoveRegion","categorizer","comparator","boardWidth","boardHeight","moves","this","Map","move","wouldFlip","set","bestMove","bestKeyYet","undefined","bestValYet","currentKey","currentVal","getMapMax","get","size","isCorner","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","isInterior","loopOverBoard","modifier","j","i","flippableInDirection","player","flippable","FREE","getValidMoves","nextPlayer","validMoves","_target","concat","flippablePositions","flipped","currentScore","numFlipped","isHumanMove","newScore","takeMove","position","toFlip","botGo","longestValueComparator","_k1","v1","_k2","v2","shortestValueComparator","moveRegions","flippedPosns","tryAddMove","hasMoves","getBestMove","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","noLongerWouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","gameIsOver","otherPlayersTurn","updateScore","useState","width","height","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","useEffect","boardClone","newValidMoves","botPassed","scoreDiff","target","has","setTimeout","handleHover","isEnter","changeToApply","b","bClone","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","score","setScore","diff","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.35b8f7ea.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\n  let bestKeyYet = undefined;\n  let bestValYet = undefined;\n  for (const [currentKey, currentVal] of map) {\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\n      bestKeyYet = currentKey;\n      bestValYet = currentVal;\n    }\n  }\n  return bestKeyYet;\n}\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n  noLongerWouldBeFlipped: boolean;\n  justPlaced: boolean;\n  justFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return '👍';\n  } else if (marker === Marker.BOT) {\n    return '🤖';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction otherMarker(marker: Marker): Marker {\n  return getMarker(marker !== Marker.HUMAN);\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n        noLongerWouldBeFlipped: false,\n        justPlaced: false,\n        justFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction cloneBoardArray(board: BoardArray): BoardArray {\n  const ret: BoardArray = [];\n  for (const row of board) {\n    const newRow: SquareContent[] = [];\n    for (const sc of row) {\n      newRow.push({ ...sc });\n    }\n    ret.push(newRow);\n  }\n  return ret;\n}\n\nclass MoveRegion {\n  private categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean;\n  private comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number;\n  private boardWidth: number;\n  private boardHeight: number;\n  private moves: ValidMoves;\n\n  constructor(\n    categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean,\n    comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number,\n    boardWidth: number,\n    boardHeight: number,\n  ) {\n    this.categorizer = categorizer;\n    this.comparator = comparator;\n    this.boardWidth = boardWidth;\n    this.boardHeight = boardHeight;\n    this.moves = new Map<string, Coordinate[]>();\n  }\n\n  tryAddMove(move: string, wouldFlip: Coordinate[]): boolean {\n    if (this.categorizer(stringToCoord(move), this.boardWidth, this.boardHeight) && wouldFlip.length > 0) {\n      this.moves.set(move, wouldFlip);\n      return true;\n    }\n    return false;\n  }\n\n  getBestMove(): [string, Coordinate[]] {\n    const bestMove = getMapMax(this.moves, this.comparator) || '';\n    return [bestMove, this.moves.get(bestMove) || []];\n  }\n\n  hasMoves(): boolean {\n    return this.moves.size > 0;\n  }\n}\n\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\n}\n\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\n  );\n}\n\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) &&\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\n  );\n}\n\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\n  );\n}\n\nfunction isInterior(...args: [Coordinate, number, number]): boolean {\n  return !isCorner(...args) && !isCornerAdjacent(...args) && !isEdge(...args) && !isEdgeAdjacent(...args);\n}\n\nfunction loopOverBoard(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  loopOverBoard(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction flipped(currentScore: Score, numFlipped: number, isHumanMove: boolean): Score {\n  const newScore: Score = [...currentScore];\n  if (isHumanMove) {\n    newScore[0] += 1 + numFlipped;\n    newScore[1] -= numFlipped;\n  } else {\n    newScore[0] -= numFlipped;\n    newScore[1] += 1 + numFlipped;\n  }\n  return newScore;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  // Get the list of possible moves. If none, return.\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n\n  // Sort the moves based on their position on the board.\n  const boardHeight = board.length;\n  const boardWidth = board[0].length;\n  const longestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v2.length - v1.length;\n  const shortestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v1.length - v2.length;\n  const moveRegions: MoveRegion[] = [\n    new MoveRegion(isCorner, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdge, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isInterior, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdgeAdjacent, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isCornerAdjacent, shortestValueComparator, boardWidth, boardHeight),\n  ];\n\n  let move = '';\n  let flippedPosns: Coordinate[] = [];\n  for (const [key] of validMoves) {\n    for (let i = 0; i < moveRegions.length; ++i) {\n      if (moveRegions[i].tryAddMove(key, validMoves.get(key) || [])) {\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < moveRegions.length; ++i) {\n    if (moveRegions[i].hasMoves()) {\n      const bestMove = moveRegions[i].getBestMove();\n      move = bestMove[0];\n      flippedPosns = bestMove[1];\n      if (move) {\n        break;\n      }\n    }\n  }\n  const [x, y] = stringToCoord(move);\n\n  // Modify the board to reflect the chosen move.\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  board[y][x].justPlaced = true;\n  for (const [i, j] of flippedPosns) {\n    board[j][i].justFlipped = true;\n  }\n\n  // Return the number of pieces flipped.\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n  }\n  if (value.noLongerWouldBeFlipped) {\n    cssClasses += ' no-longer-would-be-flipped';\n  }\n  if (value.justPlaced) {\n    cssClasses += ' just-placed';\n  }\n  if (value.justFlipped) {\n    cssClasses += ' just-flipped';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <div className=\"square-container\">\n        <div className=\"square-front\">{markerToStr(value.marker)}</div>\n        <div className=\"square-back\">{markerToStr(otherMarker(value.marker))}</div>\n      </div>\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (score: Score) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, nextPlayer, isGameOver, gameIsOver, otherPlayersTurn, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  useEffect(() => {\n    if (nextPlayer !== Marker.BOT || isGameOver) return;\n    const boardClone = cloneBoardArray(board);\n    let newValidMoves: ValidMoves = new Map<string, Coordinate[]>();\n    let botPassed = false;\n    let scoreDiff: [number, number] = [0, 0];\n    do {\n      // Let the bot take its turn.\n      const numFlipped = botGo(boardClone);\n      botPassed = numFlipped === 0;\n      if (numFlipped > 0) {\n        scoreDiff = flipped(scoreDiff, numFlipped, false);\n      }\n\n      // Determine whether there are any valid moves for humans; if there\n      // aren't and the bot passed, then the game is over.\n      newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n      if (newValidMoves.size === 0 && botPassed) {\n        gameIsOver();\n      }\n\n      // If the bot went and the human cannot go, the bot can go again.\n    } while (newValidMoves.size === 0 && !botPassed);\n\n    // Mark valid moves on the board.\n    loopOverBoard(boardClone, (target, x, y) => {\n      target.isValidMove = newValidMoves.has(coordToString([x, y]));\n    });\n\n    // End turn and persist board changes, new set of valid moves, and new score.\n    setTimeout(() => {\n      otherPlayersTurn();\n      setBoard(boardClone);\n      setValidMoves(newValidMoves);\n      updateScore(scoreDiff);\n    }, 500);\n  }, [nextPlayer]);\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = cloneBoardArray(board);\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    const scoreDiff = flipped([0, 0], validMoves.get(currentKey)?.length || 0, true);\n\n    // Clear data about what happened previously.\n    loopOverBoard(boardClone, (target) => {\n      target.isValidMove = false;\n      target.wouldBeFlipped = false;\n      target.justPlaced = false;\n      target.justFlipped = false;\n      target.noLongerWouldBeFlipped = false;\n    });\n\n    // End turn and persist board changes, new set of valid moves, and new score.\n    otherPlayersTurn();\n    setBoard(boardClone);\n    setValidMoves(new Map<string, Coordinate[]>());\n    updateScore(scoreDiff);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const changeToApply = isEnter\n      ? (sc: SquareContent) => {\n          sc.wouldBeFlipped = true;\n          sc.noLongerWouldBeFlipped = false;\n        }\n      : (sc: SquareContent) => {\n          sc.wouldBeFlipped = false;\n          sc.noLongerWouldBeFlipped = true;\n        };\n    setBoard((b) => {\n      const bClone = cloneBoardArray(b);\n      for (const [i, j] of validMoves.get(currentKey) || []) {\n        changeToApply(bClone[j][i]);\n      }\n      return bClone;\n    });\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n\n  function updateScore(diff: Score): void {\n    const newScore: Score = [...score];\n    newScore[0] += diff[0];\n    newScore[1] += diff[1];\n    setScore(newScore);\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"status\">{isGameOver ? 'Game over.\\n' : `Next player: ${markerToStr(nextPlayer)}\\n`}</div>\n      <div className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</div>\n      <div className=\"game-board\">\n        <Board\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}