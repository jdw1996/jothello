{"version":3,"sources":["index.tsx"],"names":["Marker","markerToStr","marker","HUMAN","BOT","modifySquareContents","board","modifier","j","length","i","flippableInDirection","x","y","player","flippable","FREE","push","getValidMoves","boardArray","nextPlayer","validMoves","Map","_target","concat","flippablePositions","set","flipped","currentScore","numFlipped","isHumanMove","newScore","botGo","ret","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","boardWidth","boardHeight","isGameOver","gameIsOver","updateScore","useState","width","height","row","halfWidth","Math","floor","halfHeight","forEach","_v","k","split","Number","createBoardArray","setBoardArray","setValidMoves","handleHover","isEnter","currentKey","has","boardArrayClone","slice","get","map","key","sc","newValidMoves","botPassed","size","botMove","botMoveX","target","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","score","setScore","otherPlayersTurn","ReactDOM","render","document","getElementById"],"mappings":"sKAIKA,E,2DAML,SAASC,EAAYC,GACnB,OAAIA,IAAWF,EAAOG,MACb,eACED,IAAWF,EAAOI,IACpB,eAEA,GAwCX,SAASC,EACPC,EACAC,GAEA,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAMG,SAAUD,EAClC,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAME,GAAGC,SAAUC,EACrCH,EAASD,EAAME,GAAGE,GAAIA,EAAGF,GAK/B,SAASG,EACPL,EACAM,EACAC,EACAH,EACAF,EACAM,GAGA,IADA,IAAMC,EAAgC,KACzB,CAGX,GADAF,GAAKL,GADLI,GAAKF,GAEG,GAAKE,GAAKN,EAAM,GAAGG,QAAUI,EAAI,GAAKA,GAAKP,EAAMG,OACvD,MAAO,GAET,GAAIH,EAAMO,GAAGD,GAAGV,SAAWF,EAAOgB,KAChC,MAAO,GACF,GAAIV,EAAMO,GAAGD,GAAGV,SAAWY,EAChC,OAAOC,EAEPA,EAAUE,KAAK,CAACL,EAAGC,KAkBzB,SAASK,EAAcC,EAA+BC,GACpD,IAAMC,EAAa,IAAIC,IAOvB,OANAjB,EAAqBc,GAAY,SAACI,EAASX,EAAGC,GAC5C,IAAME,EAhBV,SAA4BT,EAA0BM,EAAWC,EAAWC,GAC1E,GAAIR,EAAMO,GAAGD,GAAGV,SAAWF,EAAOgB,KAChC,MAAO,GAGT,IADA,IAAID,EAAgC,GAC3BL,GAAK,EAAGA,GAAK,IAAKA,EACzB,IAAK,IAAIF,GAAK,EAAGA,GAAK,IAAKA,EACzBO,EAAYA,EAAUS,OAAOb,EAAqBL,EAAOM,EAAGC,EAAGH,EAAGF,EAAGM,IAGzE,OAAOC,EAMaU,CAAmBN,EAAYP,EAAGC,EAAGO,GACnDL,EAAUN,OAAS,GACrBY,EAAWK,IAAX,UAAkBd,EAAlB,YAAuBC,GAAKE,MAGzBM,EAGT,SAASM,EAAQC,EAAgCC,EAAoBC,GACnE,IAAMC,EAA0B,YAAOH,GAQvC,OAPIE,GACFC,EAAS,IAAM,EAAIF,EACnBE,EAAS,IAAMF,IAEfE,EAAS,IAAMF,EACfE,EAAS,IAAM,EAAIF,GAEdE,EAGT,SAASC,EAAMX,GACb,IADkE,EAC9DY,EAAM,GADwD,cAE9CZ,GAF8C,IAElE,2BAAgC,CAC9BY,EAD8B,0BAE9B,OAJgE,8BAMlE,OAAOA,EAUT,SAASC,EAAOC,GAAkC,IACxCC,EAAuDD,EAAvDC,MAAOC,EAAgDF,EAAhDE,QAASC,EAAuCH,EAAvCG,iBAAkBC,EAAqBJ,EAArBI,iBACtCC,EAAa,SAOjB,OANIJ,EAAMK,cACRD,GAAc,qBAEZJ,EAAMM,iBACRF,GAAc,2BAGd,wBAAIG,UAAWH,EAAYH,QAASA,EAASO,aAAcN,EAAkBO,aAAcN,GACxFtC,EAAYmC,EAAMlC,SAgBzB,SAAS4C,EAAMX,GAAiC,IACtCY,EAA+EZ,EAA/EY,WAAYC,EAAmEb,EAAnEa,YAAaC,EAAsDd,EAAtDc,WAAYC,EAA0Cf,EAA1Ce,WAAYtB,EAA8BO,EAA9BP,aAAcuB,EAAgBhB,EAAhBgB,YAD1B,EAETC,mBA/ItC,SAA0BC,EAAeC,EAAgBlC,GAEvD,IADA,IAAMa,EAAyB,GACtBzB,EAAI,EAAGA,EAAI8C,IAAU9C,EAAG,CAE/B,IADA,IAAM+C,EAAM,GACH7C,EAAI,EAAGA,EAAI2C,IAAS3C,EAC3B6C,EAAItC,KAAK,CACPf,OAAQF,EAAOgB,KACfyB,aAAa,EACbC,gBAAgB,IAGpBT,EAAIhB,KAAKsC,GAEX,IAAMC,EAAYC,KAAKC,MAAML,EAAQ,GAC/BM,EAAaF,KAAKC,MAAMJ,EAAS,GASvC,OARArB,EAAI0B,GAAYH,GAAWtD,OAASF,EAAOI,IAC3C6B,EAAI0B,GAAYH,EAAY,GAAGtD,OAASF,EAAOG,MAC/C8B,EAAI0B,EAAa,GAAGH,GAAWtD,OAASF,EAAOG,MAC/C8B,EAAI0B,EAAa,GAAGH,EAAY,GAAGtD,OAASF,EAAOI,IACnDc,EAAce,EAAKb,GAAYwC,SAAQ,SAACC,EAAIC,GAAO,IAAD,EACjCA,EAAEC,MAAM,KADyB,mBACzCnD,EADyC,KACtCC,EADsC,KAEhDoB,EAAI+B,OAAOnD,IAAImD,OAAOpD,IAAI6B,aAAc,KAEnCR,EAwHsCgC,CAAiBlB,EAAYC,EAAahD,EAAOG,QAFjD,mBAEtCgB,EAFsC,KAE1B+C,EAF0B,OAGTd,mBAASlC,EAAcC,EAAYnB,EAAOG,QAHjC,mBAGtCkB,EAHsC,KAG1B8C,EAH0B,KAiEvCC,EAAc,SAACxD,EAAWC,EAAWwD,GACzC,IAAMC,EAAU,UAAM1D,EAAN,YAAWC,GAC3B,GAAKQ,EAAWkD,IAAID,GAApB,CAGA,IAL8D,EAKxDE,EAAkBrD,EAAWsD,QAL2B,cAMzCpD,EAAWqD,IAAIJ,IAAe,IANW,IAM9D,2BAAuD,CAAC,IAAD,yBAA3C5D,EAA2C,KACrD8D,EADqD,MAClC9D,GAAGgC,eAAiB2B,GAPqB,8BAS9DH,EAAcM,KAGhB,OACE,6BACE,+BACE,+BACGrD,EAAWwD,KAAI,SAACpB,EAAK1C,GAAN,OACd,wBAAI+D,IAAK/D,EAAG8B,UAAU,aACnBY,EAAIoB,KAAI,SAACE,EAAIjE,GAAL,OACP,kBAACsB,EAAD,CACE0C,IAAG,UAAKhE,EAAL,YAAUC,GACbuB,MAAOyC,EACPxC,QAAS,kBAlFA,SAACzB,EAAWC,GAAe,IAAD,EAEjD,IAAIoC,EAAJ,CAKA,IAAMqB,EAAU,UAAM1D,EAAN,YAAWC,GAC3B,GAAKQ,EAAWkD,IAAID,GAApB,CAKA,IAAME,EAAkBrD,EAAWsD,QACnCD,EAAgB3D,GAAGD,GAAGV,OAASF,EAAOG,MAdW,oBAe5BkB,EAAWqD,IAAIJ,IAAe,IAfF,IAejD,2BAAuD,CAAC,IAAD,yBAA3C5D,EAA2C,KACrD8D,EADqD,MAClC9D,GAAGR,OAASF,EAAOG,OAhBS,8BAqBjD,IAHA,IAAI4B,EAAWJ,EAAQC,GAAc,UAAAP,EAAWqD,IAAIJ,UAAf,eAA4B7D,SAAU,GAAG,GAC1EqE,EAAiDzD,IAExC,CACX,IAAI0D,GAAY,EAEhB,GAA2B,KAD3BD,EAAgB5D,EAAcsD,EAAiBxE,EAAOI,MACpC4E,KAChBD,GAAY,MACP,CAAC,IAAD,EACCE,EAAUjD,EAAM8C,GADjB,EAEwBG,EAAQlB,MAAM,KAAKY,IAAIX,QAF/C,mBAEEkB,EAFF,KAGLV,EAHK,MAGqBU,GAAUhF,OAASF,EAAOI,IAH/C,oBAIgB0E,EAAcJ,IAAIO,IAAY,IAJ9C,IAIL,2BAAuD,CAAC,IAAD,yBAA3CvE,EAA2C,KACrD8D,EADqD,MAClC9D,GAAGR,OAASF,EAAOI,KALnC,8BAOL2B,EAAWJ,EAAQI,GAAU,UAAA+C,EAAcJ,IAAIO,UAAlB,eAA4BxE,SAAU,GAAG,GAGxE,GAA2B,KAD3BqE,EAAgB5D,EAAcsD,EAAiBxE,EAAOG,QACpC6E,KAQhB,MAPA,GAAID,EAAW,CACb7B,IACA,OAUN7C,EAAqBmE,GAAiB,SAACW,EAAQvE,EAAGC,GAChDsE,EAAO1C,YAAcqC,EAAcP,IAAd,UAAqB3D,EAArB,YAA0BC,IAC/CsE,EAAOzC,gBAAiB,KAI1BwB,EAAcM,GACdL,EAAcW,GACd3B,EAAYpB,KAyBiBqD,CAAiBxE,EAAGC,IACnCyB,iBAAkB,kBAAM8B,EAAYxD,EAAGC,GAAG,IAC1C0B,iBAAkB,kBAAM6B,EAAYxD,EAAGC,GAAG,gBAW5D,SAASwE,IACP,IAD2B,EAGWjC,oBAAS,GAHpB,mBAGpBkC,EAHoB,KAGPC,EAHO,KAIrBnE,EAAuBkE,EA9PZtF,EAAOG,MAAQH,EAAOI,IA0PZ,EAKSgD,oBAAS,GALlB,mBAKpBH,EALoB,KAKRuC,EALQ,OAMDpC,mBAA2B,CAAC,EAAG,IAN9B,mBAMpBqC,EANoB,KAMbC,EANa,KAQ3B,OACE,yBAAK/C,UAAU,QACb,yBAAKA,UAAU,UAAUM,EAAa,eAAH,uBAAoChD,EAAYmB,GAAhD,OACnC,yBAAKuB,UAAU,SAAf,uBAAwC8C,EAAM,GAA9C,gBAAwDxF,EAAYD,EAAOG,OAA3E,gBACEsF,EAAM,GADR,gBAEQxF,EAAYD,EAAOI,KAF3B,MAGA,yBAAKuC,UAAU,cACb,kBAACG,EAAD,CACEC,WAdY,EAeZC,YAhBa,EAiBb5B,WAAYA,EACZ6B,WAAYA,EACZC,WAAY,kBAAMsC,GAAc,IAChCG,iBAAkB,kBAAMJ,GAAgBD,IACxC1D,aAAc6D,EACdtC,YAAauC,O,SAlSlB1F,O,iBAAAA,I,aAAAA,I,gBAAAA,M,KA2SL4F,IAASC,OAAO,kBAACR,EAAD,MAAUS,SAASC,eAAe,W","file":"static/js/main.07b556f2.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return 'üëç';\n  } else if (marker === Marker.BOT) {\n    return 'ü§ñ';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\ninterface SquareContent {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): SquareContent[][] {\n  const ret: SquareContent[][] = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = k.split(',');\n    ret[Number(y)][Number(x)].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction modifySquareContents(\n  board: SquareContent[][],\n  modifier: (target: SquareContent, i: number, j: number) => void,\n) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: SquareContent[][],\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): [number, number][] {\n  const flippable: [number, number][] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: SquareContent[][], x: number, y: number, player: Marker): [number, number][] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: [number, number][] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(boardArray: SquareContent[][], nextPlayer: Marker): Map<string, [number, number][]> {\n  const validMoves = new Map<string, [number, number][]>();\n  modifySquareContents(boardArray, (_target, x, y) => {\n    const flippable = flippablePositions(boardArray, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(`${x},${y}`, flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction flipped(currentScore: [number, number], numFlipped: number, isHumanMove: boolean): [number, number] {\n  const newScore: [number, number] = [...currentScore];\n  if (isHumanMove) {\n    newScore[0] += 1 + numFlipped;\n    newScore[1] -= numFlipped;\n  } else {\n    newScore[0] -= numFlipped;\n    newScore[1] += 1 + numFlipped;\n  }\n  return newScore;\n}\n\nfunction botGo(validMoves: Map<string, [number, number][]>): string {\n  let ret = '';\n  for (const [key] of validMoves) {\n    ret = key;\n    break;\n  }\n  return ret;\n}\n\ninterface SquareProps {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n}\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-human-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped-human';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      {markerToStr(value.marker)}\n    </td>\n  );\n}\n\ninterface BoardProps {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  currentScore: [number, number];\n  updateScore: (score: [number, number]) => void;\n}\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, isGameOver, gameIsOver, currentScore, updateScore } = props;\n  const [boardArray, setBoardArray] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(boardArray, Marker.HUMAN));\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = `${x},${y}`;\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardArrayClone = boardArray.slice();\n    boardArrayClone[y][x].marker = Marker.HUMAN;\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      boardArrayClone[j][i].marker = Marker.HUMAN;\n    }\n    let newScore = flipped(currentScore, validMoves.get(currentKey)?.length || 0, true);\n    let newValidMoves: Map<string, [number, number][]> = validMoves;\n\n    while (true) {\n      let botPassed = false;\n      newValidMoves = getValidMoves(boardArrayClone, Marker.BOT);\n      if (newValidMoves.size === 0) {\n        botPassed = true;\n      } else {\n        const botMove = botGo(newValidMoves);\n        const [botMoveX, botMoveY] = botMove.split(',').map(Number);\n        boardArrayClone[botMoveY][botMoveX].marker = Marker.BOT;\n        for (const [i, j] of newValidMoves.get(botMove) || []) {\n          boardArrayClone[j][i].marker = Marker.BOT;\n        }\n        newScore = flipped(newScore, newValidMoves.get(botMove)?.length || 0, false);\n      }\n      newValidMoves = getValidMoves(boardArrayClone, Marker.HUMAN);\n      if (newValidMoves.size === 0) {\n        if (botPassed) {\n          gameIsOver();\n          break;\n        } else {\n          continue;\n        }\n      } else {\n        break;\n      }\n    }\n\n    // Reset the valid moves marked on the board.\n    modifySquareContents(boardArrayClone, (target, x, y) => {\n      target.isValidMove = newValidMoves.has(`${x},${y}`);\n      target.wouldBeFlipped = false;\n    });\n\n    // Persist the board changes, the new set of valid moves, and the new score.\n    setBoardArray(boardArrayClone);\n    setValidMoves(newValidMoves);\n    updateScore(newScore);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = `${x},${y}`;\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const boardArrayClone = boardArray.slice();\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      boardArrayClone[j][i].wouldBeFlipped = isEnter;\n    }\n    setBoardArray(boardArrayClone);\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {boardArray.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={`${x} ${y}`}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<[number, number]>([2, 2]);\n\n  return (\n    <div className=\"game\">\n      <div className=\"status\">{isGameOver ? 'Game over.\\n' : `Next player: ${markerToStr(nextPlayer)}\\n`}</div>\n      <div className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</div>\n      <div className=\"game-board\">\n        <Board\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          currentScore={score}\n          updateScore={setScore}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}