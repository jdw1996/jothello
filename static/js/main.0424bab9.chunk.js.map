{"version":3,"sources":["index.tsx"],"names":["Marker","getMapMax","map","comparator","bestKeyYet","undefined","bestValYet","currentKey","currentVal","markerToStr","marker","HUMAN","BOT","getMarker","isHuman","coordToString","coord","stringToCoord","key","ret","split","Number","length","Error","isCorner","boardWidth","boardHeight","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","modifySquareContents","board","modifier","j","i","flippableInDirection","player","flippable","FREE","push","getValidMoves","nextPlayer","validMoves","Map","_target","concat","flippablePositions","set","flipped","currentScore","numFlipped","isHumanMove","newScore","takeMove","position","toFlip","botGo","size","move","corners","cornerAdjacent","edges","edgeAdjacent","interior","checkingArgs","settingArgs","get","_k1","v1","_k2","v2","flippedPosns","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","noLongerWouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","gameIsOver","updateScore","useState","width","height","row","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","handleHover","isEnter","has","boardClone","slice","changeToApply","sc","scoreDiff","target","newValidMoves","botPassed","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","score","setScore","otherPlayersTurn","diff","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.0424bab9.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\n  let bestKeyYet = undefined;\n  let bestValYet = undefined;\n  for (const [currentKey, currentVal] of map) {\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\n      bestKeyYet = currentKey;\n      bestValYet = currentVal;\n    }\n  }\n  return bestKeyYet;\n}\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n  noLongerWouldBeFlipped: boolean;\n  justPlaced: boolean;\n  justFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return '👍';\n  } else if (marker === Marker.BOT) {\n    return '🤖';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction otherMarker(marker: Marker): Marker {\n  return getMarker(marker !== Marker.HUMAN);\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n        noLongerWouldBeFlipped: false,\n        justPlaced: false,\n        justFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\n}\n\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\n  );\n}\n\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\n  );\n}\n\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\n  );\n}\n\nfunction modifySquareContents(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  modifySquareContents(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction flipped(currentScore: Score, numFlipped: number, isHumanMove: boolean): Score {\n  const newScore: Score = [...currentScore];\n  if (isHumanMove) {\n    newScore[0] += 1 + numFlipped;\n    newScore[1] -= numFlipped;\n  } else {\n    newScore[0] -= numFlipped;\n    newScore[1] += 1 + numFlipped;\n  }\n  return newScore;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  // Get the list of possible moves. If none, return.\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n\n  // Sort the moves based on their position on the board.\n  let move = '';\n  const boardHeight = board.length;\n  const boardWidth = board[0].length;\n  const corners = new Map<string, Coordinate[]>();\n  const cornerAdjacent = new Map<string, Coordinate[]>();\n  const edges = new Map<string, Coordinate[]>();\n  const edgeAdjacent = new Map<string, Coordinate[]>();\n  const interior = new Map<string, Coordinate[]>();\n  for (const [key] of validMoves) {\n    const checkingArgs: [Coordinate, number, number] = [stringToCoord(key), boardWidth, boardHeight];\n    const settingArgs: [string, Coordinate[]] = [key, validMoves.get(key) || []];\n    if (isCorner(...checkingArgs)) {\n      corners.set(...settingArgs);\n    } else if (isCornerAdjacent(...checkingArgs)) {\n      cornerAdjacent.set(...settingArgs);\n    } else if (isEdge(...checkingArgs)) {\n      edges.set(...settingArgs);\n    } else if (isEdgeAdjacent(...checkingArgs)) {\n      edgeAdjacent.set(...settingArgs);\n    } else {\n      interior.set(...settingArgs);\n    }\n  }\n  if (corners.size > 0) {\n    // If any corner moves are available, choose the one that flips the most\n    // pieces.\n    move = getMapMax(corners, (_k1, v1, _k2, v2) => v2.length - v1.length) || move;\n  } else if (edges.size > 0) {\n    // If any edge moves are available, choose the one that flips the most\n    // pieces.\n    move = getMapMax(edges, (_k1, v1, _k2, v2) => v2.length - v1.length) || move;\n  } else if (interior.size > 0) {\n    // If any interior moves are available, choose the one that flips the fewest\n    // pieces.\n    move = getMapMax(interior, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  } else if (edgeAdjacent.size > 0) {\n    // If any edge-adjacent moves are available, choose the one that flips the\n    // fewest pieces.\n    move = getMapMax(edgeAdjacent, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  } else {\n    // If only corner-adjacent moves are available, choose the one that flips\n    // the fewest pieces.\n    move = getMapMax(cornerAdjacent, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  }\n  const [x, y] = stringToCoord(move);\n\n  // Modify the board to reflect the chosen move.\n  const flippedPosns: Coordinate[] = validMoves.get(move) || [];\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  board[y][x].justPlaced = true;\n  for (const [i, j] of flippedPosns) {\n    board[j][i].justFlipped = true;\n  }\n\n  // Return the number of pieces flipped.\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n  }\n  if (value.noLongerWouldBeFlipped) {\n    cssClasses += ' no-longer-would-be-flipped';\n  }\n  if (value.justPlaced) {\n    cssClasses += ' just-placed';\n  }\n  if (value.justFlipped) {\n    cssClasses += ' just-flipped';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <div className=\"square-container\">\n        <div className=\"square-front\">{markerToStr(value.marker)}</div>\n        <div className=\"square-back\">{markerToStr(otherMarker(value.marker))}</div>\n      </div>\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (score: Score) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, isGameOver, gameIsOver, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = board.slice();\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    let scoreDiff = flipped([0, 0], validMoves.get(currentKey)?.length || 0, true);\n\n    // Clear data about what the bot did previously.\n    modifySquareContents(boardClone, (target) => {\n      target.justPlaced = false;\n      target.justFlipped = false;\n      target.noLongerWouldBeFlipped = false;\n    });\n\n    let newValidMoves: ValidMoves = validMoves;\n    let botPassed = false;\n    do {\n      // Let the bot take its turn.\n      const numFlipped = botGo(boardClone);\n      botPassed = numFlipped === 0;\n      if (numFlipped > 0) {\n        scoreDiff = flipped(scoreDiff, numFlipped, false);\n      }\n\n      // Determine whether there are any valid moves for humans; if there\n      // aren't and the bot passed, then the game is over.\n      newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n      if (newValidMoves.size === 0 && botPassed) {\n        gameIsOver();\n      }\n\n      // If the bot went and the human cannot go, the bot can go again.\n    } while (newValidMoves.size === 0 && !botPassed);\n\n    // Reset the valid moves marked on the board.\n    modifySquareContents(boardClone, (target, x, y) => {\n      target.isValidMove = newValidMoves.has(coordToString([x, y]));\n      target.wouldBeFlipped = false;\n    });\n\n    // Persist the board changes, the new set of valid moves, and the new score.\n    setBoard(boardClone);\n    setValidMoves(newValidMoves);\n    updateScore(scoreDiff);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const boardClone = board.slice();\n    const changeToApply = isEnter\n      ? (sc: SquareContent) => {\n          sc.wouldBeFlipped = true;\n          sc.noLongerWouldBeFlipped = false;\n        }\n      : (sc: SquareContent) => {\n          sc.wouldBeFlipped = false;\n          sc.noLongerWouldBeFlipped = true;\n        };\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      changeToApply(boardClone[j][i]);\n    }\n    setBoard(boardClone);\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n\n  function updateScore(diff: Score): void {\n    const newScore: Score = [...score];\n    newScore[0] += diff[0];\n    newScore[1] += diff[1];\n    setScore(newScore);\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"status\">{isGameOver ? 'Game over.\\n' : `Next player: ${markerToStr(nextPlayer)}\\n`}</div>\n      <div className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</div>\n      <div className=\"game-board\">\n        <Board\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}