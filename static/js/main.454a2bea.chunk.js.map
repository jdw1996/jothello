{"version":3,"sources":["index.tsx"],"names":["Marker","sleep","ms","Promise","v","setTimeout","markerToStr","marker","HUMAN","BOT","getMarker","isHuman","coordToString","coord","stringToCoord","key","ret","split","map","Number","length","Error","cloneBoardArray","board","row","newRow","sc","push","MoveRegion","categorizer","comparator","boardWidth","boardHeight","moves","this","Map","move","wouldFlip","set","bestMove","bestKeyYet","undefined","bestValYet","currentKey","currentVal","getMapMax","get","size","isCorner","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","isInterior","loopOverBoard","modifier","j","i","flippableInDirection","player","flippable","FREE","getValidMoves","nextPlayer","validMoves","_target","concat","flippablePositions","takeMove","position","toFlip","botGo","longestValueComparator","_k1","v1","_k2","v2","shortestValueComparator","moveRegions","flippedPosns","tryAddMove","hasMoves","getBestMove","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","noLongerWouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","score","gameIsOver","otherPlayersTurn","updateScore","useState","width","height","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","useEffect","a","boardClone","endGame","numFlipped","newValidMoves","target","has","f","handleHover","isEnter","changeToApply","b","bClone","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","setScore","boardKey","setBoardKey","gameDialog","setGameDialog","winner","toString","padStart","n","id","s","sClone","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.454a2bea.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\n  let bestKeyYet = undefined;\n  let bestValYet = undefined;\n  for (const [currentKey, currentVal] of map) {\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\n      bestKeyYet = currentKey;\n      bestValYet = currentVal;\n    }\n  }\n  return bestKeyYet;\n}\n\nfunction sleep(ms: number): Promise<unknown> {\n  return new Promise((v) => setTimeout(v, ms));\n}\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n  noLongerWouldBeFlipped: boolean;\n  justPlaced: boolean;\n  justFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return '👍';\n  } else if (marker === Marker.BOT) {\n    return '🤖';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction otherMarker(marker: Marker): Marker {\n  return getMarker(marker !== Marker.HUMAN);\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n        noLongerWouldBeFlipped: false,\n        justPlaced: false,\n        justFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction cloneBoardArray(board: BoardArray): BoardArray {\n  const ret: BoardArray = [];\n  for (const row of board) {\n    const newRow: SquareContent[] = [];\n    for (const sc of row) {\n      newRow.push({ ...sc });\n    }\n    ret.push(newRow);\n  }\n  return ret;\n}\n\nclass MoveRegion {\n  private categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean;\n  private comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number;\n  private boardWidth: number;\n  private boardHeight: number;\n  private moves: ValidMoves;\n\n  constructor(\n    categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean,\n    comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number,\n    boardWidth: number,\n    boardHeight: number,\n  ) {\n    this.categorizer = categorizer;\n    this.comparator = comparator;\n    this.boardWidth = boardWidth;\n    this.boardHeight = boardHeight;\n    this.moves = new Map<string, Coordinate[]>();\n  }\n\n  tryAddMove(move: string, wouldFlip: Coordinate[]): boolean {\n    if (this.categorizer(stringToCoord(move), this.boardWidth, this.boardHeight) && wouldFlip.length > 0) {\n      this.moves.set(move, wouldFlip);\n      return true;\n    }\n    return false;\n  }\n\n  getBestMove(): [string, Coordinate[]] {\n    const bestMove = getMapMax(this.moves, this.comparator) || '';\n    return [bestMove, this.moves.get(bestMove) || []];\n  }\n\n  hasMoves(): boolean {\n    return this.moves.size > 0;\n  }\n}\n\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\n}\n\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\n  );\n}\n\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) &&\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\n  );\n}\n\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\n  );\n}\n\nfunction isInterior(...args: [Coordinate, number, number]): boolean {\n  return !isCorner(...args) && !isCornerAdjacent(...args) && !isEdge(...args) && !isEdgeAdjacent(...args);\n}\n\nfunction loopOverBoard(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  loopOverBoard(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  // Get the list of possible moves. If none, return.\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n\n  // Sort the moves based on their position on the board.\n  const boardHeight = board.length;\n  const boardWidth = board[0].length;\n  const longestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v2.length - v1.length;\n  const shortestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v1.length - v2.length;\n  const moveRegions: MoveRegion[] = [\n    new MoveRegion(isCorner, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdge, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isInterior, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdgeAdjacent, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isCornerAdjacent, shortestValueComparator, boardWidth, boardHeight),\n  ];\n\n  let move = '';\n  let flippedPosns: Coordinate[] = [];\n  for (const [key] of validMoves) {\n    for (let i = 0; i < moveRegions.length; ++i) {\n      if (moveRegions[i].tryAddMove(key, validMoves.get(key) || [])) {\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < moveRegions.length; ++i) {\n    if (moveRegions[i].hasMoves()) {\n      const bestMove = moveRegions[i].getBestMove();\n      move = bestMove[0];\n      flippedPosns = bestMove[1];\n      if (move) {\n        break;\n      }\n    }\n  }\n  const [x, y] = stringToCoord(move);\n\n  // Modify the board to reflect the chosen move.\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  board[y][x].justPlaced = true;\n  for (const [i, j] of flippedPosns) {\n    board[j][i].justFlipped = true;\n  }\n\n  // Return the number of pieces flipped.\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n  }\n  if (value.noLongerWouldBeFlipped) {\n    cssClasses += ' no-longer-would-be-flipped';\n  }\n  if (value.justPlaced) {\n    cssClasses += ' just-placed';\n  }\n  if (value.justFlipped) {\n    cssClasses += ' just-flipped';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <div className=\"square-container\">\n        <div className=\"square-front\">{markerToStr(value.marker)}</div>\n        <div className=\"square-back\">{markerToStr(otherMarker(value.marker))}</div>\n      </div>\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  score: Score;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (numFlipped: number, player: Marker) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, nextPlayer, isGameOver, score, gameIsOver, otherPlayersTurn, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  useEffect(() => {\n    const f = async () => {\n      // If it's the human's turn or the game is over, do nothing.\n      if (nextPlayer !== Marker.BOT || isGameOver) return;\n\n      const boardClone = cloneBoardArray(board);\n      let endGame = false;\n\n      // Let the bot take its turn.\n      const numFlipped = botGo(boardClone);\n\n      // If the bot made a move, wait before persisting changes.\n      await sleep(numFlipped ? 500 : 0);\n\n      // Find the possible moves for the human.\n      const newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n      if (newValidMoves.size > 0) {\n        // If the human can go, it is their turn.\n        otherPlayersTurn();\n        // Mark valid moves on the board.\n        loopOverBoard(boardClone, (target, x, y) => {\n          target.isValidMove = newValidMoves.has(coordToString([x, y]));\n        });\n      } else if (numFlipped === 0) {\n        // If the human can't go and the bot passed, the game is over.\n        endGame = true;\n      }\n\n      endGame && gameIsOver();\n      setBoard(boardClone);\n      setValidMoves(newValidMoves);\n      updateScore(numFlipped, Marker.BOT);\n    };\n    f();\n  }, [score]);\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = cloneBoardArray(board);\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    const numFlipped = validMoves.get(currentKey)?.length || 0;\n\n    // Clear data about what happened previously.\n    loopOverBoard(boardClone, (target) => {\n      target.isValidMove = false;\n      target.wouldBeFlipped = false;\n      target.justPlaced = false;\n      target.justFlipped = false;\n      target.noLongerWouldBeFlipped = false;\n    });\n\n    // End turn and persist board changes, new set of valid moves, and new score.\n    otherPlayersTurn();\n    setBoard(boardClone);\n    setValidMoves(new Map<string, Coordinate[]>());\n    updateScore(numFlipped, Marker.HUMAN);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const changeToApply = isEnter\n      ? (sc: SquareContent) => {\n          sc.wouldBeFlipped = true;\n          sc.noLongerWouldBeFlipped = false;\n        }\n      : (sc: SquareContent) => {\n          sc.wouldBeFlipped = false;\n          sc.noLongerWouldBeFlipped = true;\n        };\n    setBoard((b) => {\n      const bClone = cloneBoardArray(b);\n      for (const [i, j] of validMoves.get(currentKey) || []) {\n        changeToApply(bClone[j][i]);\n      }\n      return bClone;\n    });\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n  const [boardKey, setBoardKey] = useState(0);\n  const [gameDialog, setGameDialog] = useState('The game is about to begin.');\n\n  useEffect(() => {\n    if (isGameOver) {\n      const winner = score[0] > score[1] ? Marker.HUMAN : Marker.BOT;\n      setGameDialog(`Game over. Player ${markerToStr(winner)} wins.`);\n    }\n  }, [isGameOver]);\n\n  function updateScore(numFlipped: number, player: Marker): void {\n    if (numFlipped === 0) return;\n    setScore((s) => {\n      const sClone: Score = [...s];\n      if (player === Marker.HUMAN) {\n        sClone[0] += 1 + numFlipped;\n        sClone[1] -= numFlipped;\n      } else {\n        sClone[0] -= numFlipped;\n        sClone[1] += 1 + numFlipped;\n      }\n      return sClone;\n    });\n    setGameDialog(`Player ${markerToStr(player)} flipped ${numFlipped} piece${numFlipped > 1 ? 's' : ''}.`);\n  }\n\n  function newGame(): void {\n    setIsHumanNext(true);\n    setIsGameOver(false);\n    setScore([2, 2]);\n    setBoardKey((n) => n + 1);\n    setGameDialog('The game is about to begin.');\n  }\n\n  return (\n    <div className=\"game\">\n      <p>\n        <span className={'human-score' + (isHumanNext && !isGameOver ? ' next-player' : '')}>{`${markerToStr(\n          Marker.HUMAN,\n        )} : ${score[0].toString().padStart(2, '0')}`}</span>\n        &emsp;\n        <span className={'bot-score' + (isHumanNext || isGameOver ? '' : ' next-player')}>{`${markerToStr(\n          Marker.BOT,\n        )} : ${score[1].toString().padStart(2, '0')}`}</span>\n        &emsp;\n        {isGameOver && <button onClick={newGame}>Reset</button>}\n      </p>\n      <div id=\"game-board\">\n        <Board\n          key={boardKey}\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          score={score}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n      <p>{gameDialog}</p>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}