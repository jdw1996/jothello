{"version":3,"sources":["index.tsx"],"names":["Marker","sleep","ms","Promise","v","setTimeout","markerToStr","marker","HUMAN","BOT","getMarker","isHuman","coordToString","coord","stringToCoord","key","ret","split","map","Number","length","Error","cloneBoardArray","board","row","newRow","sc","push","MoveRegion","categorizer","comparator","boardWidth","boardHeight","moves","this","Map","move","wouldFlip","set","bestMove","bestKeyYet","undefined","bestValYet","currentKey","currentVal","getMapMax","get","size","isCorner","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","isInterior","loopOverBoard","modifier","j","i","flippableInDirection","player","flippable","FREE","getValidMoves","nextPlayer","validMoves","_target","concat","flippablePositions","takeMove","position","toFlip","botGo","longestValueComparator","_k1","v1","_k2","v2","shortestValueComparator","moveRegions","flippedPosns","tryAddMove","hasMoves","getBestMove","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","noLongerWouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","score","gameIsOver","otherPlayersTurn","updateScore","useState","width","height","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","useEffect","a","boardClone","endGame","numFlipped","newValidMoves","target","has","f","handleHover","isEnter","changeToApply","b","bClone","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","setScore","boardKey","setBoardKey","gameDialog","setGameDialog","winner","toString","padStart","n","id","s","sClone","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.454a2bea.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\n\r\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\r\n  let bestKeyYet = undefined;\r\n  let bestValYet = undefined;\r\n  for (const [currentKey, currentVal] of map) {\r\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\r\n      bestKeyYet = currentKey;\r\n      bestValYet = currentVal;\r\n    }\r\n  }\r\n  return bestKeyYet;\r\n}\r\n\r\nfunction sleep(ms: number): Promise<unknown> {\r\n  return new Promise((v) => setTimeout(v, ms));\r\n}\r\n\r\nenum Marker {\r\n  HUMAN,\r\n  BOT,\r\n  FREE,\r\n}\r\ntype SquareContent = {\r\n  marker: Marker;\r\n  isValidMove: boolean;\r\n  wouldBeFlipped: boolean;\r\n  noLongerWouldBeFlipped: boolean;\r\n  justPlaced: boolean;\r\n  justFlipped: boolean;\r\n};\r\ntype BoardArray = SquareContent[][];\r\ntype Score = [number, number];\r\ntype Coordinate = [number, number];\r\ntype ValidMoves = Map<string, Coordinate[]>;\r\n\r\nfunction markerToStr(marker: Marker): string {\r\n  if (marker === Marker.HUMAN) {\r\n    return 'üëç';\r\n  } else if (marker === Marker.BOT) {\r\n    return 'ü§ñ';\r\n  } else {\r\n    return '';\r\n  }\r\n}\r\n\r\nfunction getMarker(isHuman: boolean): Marker {\r\n  return isHuman ? Marker.HUMAN : Marker.BOT;\r\n}\r\n\r\nfunction otherMarker(marker: Marker): Marker {\r\n  return getMarker(marker !== Marker.HUMAN);\r\n}\r\n\r\nfunction coordToString(coord: Coordinate): string {\r\n  return `${coord[0]},${coord[1]}`;\r\n}\r\n\r\nfunction stringToCoord(key: string): Coordinate {\r\n  const ret = key.split(',').map(Number);\r\n  if (ret.length === 2) return ret as Coordinate;\r\n  throw new Error('Cannot convert given string to Coordinate!');\r\n}\r\n\r\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\r\n  const ret: BoardArray = [];\r\n  for (let j = 0; j < height; ++j) {\r\n    const row = [];\r\n    for (let i = 0; i < width; ++i) {\r\n      row.push({\r\n        marker: Marker.FREE,\r\n        isValidMove: false,\r\n        wouldBeFlipped: false,\r\n        noLongerWouldBeFlipped: false,\r\n        justPlaced: false,\r\n        justFlipped: false,\r\n      });\r\n    }\r\n    ret.push(row);\r\n  }\r\n  const halfWidth = Math.floor(width / 2);\r\n  const halfHeight = Math.floor(height / 2);\r\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\r\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\r\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\r\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\r\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\r\n    const [x, y] = stringToCoord(k);\r\n    ret[y][x].isValidMove = true;\r\n  });\r\n  return ret;\r\n}\r\n\r\nfunction cloneBoardArray(board: BoardArray): BoardArray {\r\n  const ret: BoardArray = [];\r\n  for (const row of board) {\r\n    const newRow: SquareContent[] = [];\r\n    for (const sc of row) {\r\n      newRow.push({ ...sc });\r\n    }\r\n    ret.push(newRow);\r\n  }\r\n  return ret;\r\n}\r\n\r\nclass MoveRegion {\r\n  private categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean;\r\n  private comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number;\r\n  private boardWidth: number;\r\n  private boardHeight: number;\r\n  private moves: ValidMoves;\r\n\r\n  constructor(\r\n    categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean,\r\n    comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number,\r\n    boardWidth: number,\r\n    boardHeight: number,\r\n  ) {\r\n    this.categorizer = categorizer;\r\n    this.comparator = comparator;\r\n    this.boardWidth = boardWidth;\r\n    this.boardHeight = boardHeight;\r\n    this.moves = new Map<string, Coordinate[]>();\r\n  }\r\n\r\n  tryAddMove(move: string, wouldFlip: Coordinate[]): boolean {\r\n    if (this.categorizer(stringToCoord(move), this.boardWidth, this.boardHeight) && wouldFlip.length > 0) {\r\n      this.moves.set(move, wouldFlip);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  getBestMove(): [string, Coordinate[]] {\r\n    const bestMove = getMapMax(this.moves, this.comparator) || '';\r\n    return [bestMove, this.moves.get(bestMove) || []];\r\n  }\r\n\r\n  hasMoves(): boolean {\r\n    return this.moves.size > 0;\r\n  }\r\n}\r\n\r\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\r\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\r\n}\r\n\r\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\r\n  return (\r\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\r\n  );\r\n}\r\n\r\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\r\n  return (\r\n    !isCorner([x, y], boardHeight, boardWidth) &&\r\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\r\n    (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\r\n  );\r\n}\r\n\r\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\r\n  return (\r\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\r\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\r\n  );\r\n}\r\n\r\nfunction isInterior(...args: [Coordinate, number, number]): boolean {\r\n  return !isCorner(...args) && !isCornerAdjacent(...args) && !isEdge(...args) && !isEdgeAdjacent(...args);\r\n}\r\n\r\nfunction loopOverBoard(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\r\n  for (let j = 0; j < board.length; ++j) {\r\n    for (let i = 0; i < board[j].length; ++i) {\r\n      modifier(board[j][i], i, j);\r\n    }\r\n  }\r\n}\r\n\r\nfunction flippableInDirection(\r\n  board: BoardArray,\r\n  x: number,\r\n  y: number,\r\n  i: number,\r\n  j: number,\r\n  player: Marker,\r\n): Coordinate[] {\r\n  const flippable: Coordinate[] = [];\r\n  while (true) {\r\n    x += i;\r\n    y += j;\r\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\r\n      return [];\r\n    }\r\n    if (board[y][x].marker === Marker.FREE) {\r\n      return [];\r\n    } else if (board[y][x].marker === player) {\r\n      return flippable;\r\n    } else {\r\n      flippable.push([x, y]);\r\n    }\r\n  }\r\n}\r\n\r\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\r\n  if (board[y][x].marker !== Marker.FREE) {\r\n    return [];\r\n  }\r\n  let flippable: Coordinate[] = [];\r\n  for (let i = -1; i <= 1; ++i) {\r\n    for (let j = -1; j <= 1; ++j) {\r\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\r\n    }\r\n  }\r\n  return flippable;\r\n}\r\n\r\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\r\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\r\n  loopOverBoard(board, (_target, x, y) => {\r\n    const flippable = flippablePositions(board, x, y, nextPlayer);\r\n    if (flippable.length > 0) {\r\n      validMoves.set(coordToString([x, y]), flippable);\r\n    }\r\n  });\r\n  return validMoves;\r\n}\r\n\r\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\r\n  board[position[1]][position[0]].marker = player;\r\n  for (const [i, j] of toFlip) {\r\n    board[j][i].marker = player;\r\n  }\r\n}\r\n\r\nfunction botGo(board: BoardArray): number {\r\n  // Get the list of possible moves. If none, return.\r\n  const validMoves = getValidMoves(board, Marker.BOT);\r\n  if (validMoves.size === 0) return 0;\r\n\r\n  // Sort the moves based on their position on the board.\r\n  const boardHeight = board.length;\r\n  const boardWidth = board[0].length;\r\n  const longestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\r\n    v2.length - v1.length;\r\n  const shortestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\r\n    v1.length - v2.length;\r\n  const moveRegions: MoveRegion[] = [\r\n    new MoveRegion(isCorner, longestValueComparator, boardWidth, boardHeight),\r\n    new MoveRegion(isEdge, longestValueComparator, boardWidth, boardHeight),\r\n    new MoveRegion(isInterior, shortestValueComparator, boardWidth, boardHeight),\r\n    new MoveRegion(isEdgeAdjacent, shortestValueComparator, boardWidth, boardHeight),\r\n    new MoveRegion(isCornerAdjacent, shortestValueComparator, boardWidth, boardHeight),\r\n  ];\r\n\r\n  let move = '';\r\n  let flippedPosns: Coordinate[] = [];\r\n  for (const [key] of validMoves) {\r\n    for (let i = 0; i < moveRegions.length; ++i) {\r\n      if (moveRegions[i].tryAddMove(key, validMoves.get(key) || [])) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  for (let i = 0; i < moveRegions.length; ++i) {\r\n    if (moveRegions[i].hasMoves()) {\r\n      const bestMove = moveRegions[i].getBestMove();\r\n      move = bestMove[0];\r\n      flippedPosns = bestMove[1];\r\n      if (move) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  const [x, y] = stringToCoord(move);\r\n\r\n  // Modify the board to reflect the chosen move.\r\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\r\n  board[y][x].justPlaced = true;\r\n  for (const [i, j] of flippedPosns) {\r\n    board[j][i].justFlipped = true;\r\n  }\r\n\r\n  // Return the number of pieces flipped.\r\n  return flippedPosns.length;\r\n}\r\n\r\ntype SquareProps = {\r\n  value: SquareContent;\r\n  onClick: () => void;\r\n  handleMouseEnter: () => void;\r\n  handleMouseLeave: () => void;\r\n};\r\n\r\nfunction Square(props: SquareProps): JSX.Element {\r\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\r\n  let cssClasses = 'square';\r\n  if (value.isValidMove) {\r\n    cssClasses += ' valid-move';\r\n  }\r\n  if (value.wouldBeFlipped) {\r\n    cssClasses += ' would-be-flipped';\r\n  }\r\n  if (value.noLongerWouldBeFlipped) {\r\n    cssClasses += ' no-longer-would-be-flipped';\r\n  }\r\n  if (value.justPlaced) {\r\n    cssClasses += ' just-placed';\r\n  }\r\n  if (value.justFlipped) {\r\n    cssClasses += ' just-flipped';\r\n  }\r\n  return (\r\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\r\n      <div className=\"square-container\">\r\n        <div className=\"square-front\">{markerToStr(value.marker)}</div>\r\n        <div className=\"square-back\">{markerToStr(otherMarker(value.marker))}</div>\r\n      </div>\r\n    </td>\r\n  );\r\n}\r\n\r\ntype BoardProps = {\r\n  boardWidth: number;\r\n  boardHeight: number;\r\n  nextPlayer: Marker;\r\n  isGameOver: boolean;\r\n  score: Score;\r\n  gameIsOver: () => void;\r\n  otherPlayersTurn: () => void;\r\n  updateScore: (numFlipped: number, player: Marker) => void;\r\n};\r\n\r\nfunction Board(props: BoardProps): JSX.Element {\r\n  const { boardWidth, boardHeight, nextPlayer, isGameOver, score, gameIsOver, otherPlayersTurn, updateScore } = props;\r\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\r\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\r\n\r\n  useEffect(() => {\r\n    const f = async () => {\r\n      // If it's the human's turn or the game is over, do nothing.\r\n      if (nextPlayer !== Marker.BOT || isGameOver) return;\r\n\r\n      const boardClone = cloneBoardArray(board);\r\n      let endGame = false;\r\n\r\n      // Let the bot take its turn.\r\n      const numFlipped = botGo(boardClone);\r\n\r\n      // If the bot made a move, wait before persisting changes.\r\n      await sleep(numFlipped ? 500 : 0);\r\n\r\n      // Find the possible moves for the human.\r\n      const newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\r\n      if (newValidMoves.size > 0) {\r\n        // If the human can go, it is their turn.\r\n        otherPlayersTurn();\r\n        // Mark valid moves on the board.\r\n        loopOverBoard(boardClone, (target, x, y) => {\r\n          target.isValidMove = newValidMoves.has(coordToString([x, y]));\r\n        });\r\n      } else if (numFlipped === 0) {\r\n        // If the human can't go and the bot passed, the game is over.\r\n        endGame = true;\r\n      }\r\n\r\n      endGame && gameIsOver();\r\n      setBoard(boardClone);\r\n      setValidMoves(newValidMoves);\r\n      updateScore(numFlipped, Marker.BOT);\r\n    };\r\n    f();\r\n  }, [score]);\r\n\r\n  const handleBoardClick = (x: number, y: number) => {\r\n    // If the game is over, no more moves can be made.\r\n    if (isGameOver) {\r\n      return;\r\n    }\r\n\r\n    // If the clicked square is an invalid move, we do nothing.\r\n    const currentKey = coordToString([x, y]);\r\n    if (!validMoves.has(currentKey)) {\r\n      return;\r\n    }\r\n\r\n    // Since the move is valid, we save it and flip the appropriate pieces.\r\n    const boardClone = cloneBoardArray(board);\r\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\r\n    const numFlipped = validMoves.get(currentKey)?.length || 0;\r\n\r\n    // Clear data about what happened previously.\r\n    loopOverBoard(boardClone, (target) => {\r\n      target.isValidMove = false;\r\n      target.wouldBeFlipped = false;\r\n      target.justPlaced = false;\r\n      target.justFlipped = false;\r\n      target.noLongerWouldBeFlipped = false;\r\n    });\r\n\r\n    // End turn and persist board changes, new set of valid moves, and new score.\r\n    otherPlayersTurn();\r\n    setBoard(boardClone);\r\n    setValidMoves(new Map<string, Coordinate[]>());\r\n    updateScore(numFlipped, Marker.HUMAN);\r\n  };\r\n\r\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\r\n    const currentKey = coordToString([x, y]);\r\n    if (!validMoves.has(currentKey)) {\r\n      return;\r\n    }\r\n    const changeToApply = isEnter\r\n      ? (sc: SquareContent) => {\r\n          sc.wouldBeFlipped = true;\r\n          sc.noLongerWouldBeFlipped = false;\r\n        }\r\n      : (sc: SquareContent) => {\r\n          sc.wouldBeFlipped = false;\r\n          sc.noLongerWouldBeFlipped = true;\r\n        };\r\n    setBoard((b) => {\r\n      const bClone = cloneBoardArray(b);\r\n      for (const [i, j] of validMoves.get(currentKey) || []) {\r\n        changeToApply(bClone[j][i]);\r\n      }\r\n      return bClone;\r\n    });\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <table>\r\n        <tbody>\r\n          {board.map((row, y) => (\r\n            <tr key={y} className=\"board-row\">\r\n              {row.map((sc, x) => (\r\n                <Square\r\n                  key={coordToString([x, y])}\r\n                  value={sc}\r\n                  onClick={() => handleBoardClick(x, y)}\r\n                  handleMouseEnter={() => handleHover(x, y, true)}\r\n                  handleMouseLeave={() => handleHover(x, y, false)}\r\n                />\r\n              ))}\r\n            </tr>\r\n          ))}\r\n        </tbody>\r\n      </table>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction Game(): JSX.Element {\r\n  const BOARD_HEIGHT = 8;\r\n  const BOARD_WIDTH = 8;\r\n  const [isHumanNext, setIsHumanNext] = useState(true);\r\n  const nextPlayer = getMarker(isHumanNext);\r\n  const [isGameOver, setIsGameOver] = useState(false);\r\n  const [score, setScore] = useState<Score>([2, 2]);\r\n  const [boardKey, setBoardKey] = useState(0);\r\n  const [gameDialog, setGameDialog] = useState('The game is about to begin.');\r\n\r\n  useEffect(() => {\r\n    if (isGameOver) {\r\n      const winner = score[0] > score[1] ? Marker.HUMAN : Marker.BOT;\r\n      setGameDialog(`Game over. Player ${markerToStr(winner)} wins.`);\r\n    }\r\n  }, [isGameOver]);\r\n\r\n  function updateScore(numFlipped: number, player: Marker): void {\r\n    if (numFlipped === 0) return;\r\n    setScore((s) => {\r\n      const sClone: Score = [...s];\r\n      if (player === Marker.HUMAN) {\r\n        sClone[0] += 1 + numFlipped;\r\n        sClone[1] -= numFlipped;\r\n      } else {\r\n        sClone[0] -= numFlipped;\r\n        sClone[1] += 1 + numFlipped;\r\n      }\r\n      return sClone;\r\n    });\r\n    setGameDialog(`Player ${markerToStr(player)} flipped ${numFlipped} piece${numFlipped > 1 ? 's' : ''}.`);\r\n  }\r\n\r\n  function newGame(): void {\r\n    setIsHumanNext(true);\r\n    setIsGameOver(false);\r\n    setScore([2, 2]);\r\n    setBoardKey((n) => n + 1);\r\n    setGameDialog('The game is about to begin.');\r\n  }\r\n\r\n  return (\r\n    <div className=\"game\">\r\n      <p>\r\n        <span className={'human-score' + (isHumanNext && !isGameOver ? ' next-player' : '')}>{`${markerToStr(\r\n          Marker.HUMAN,\r\n        )} : ${score[0].toString().padStart(2, '0')}`}</span>\r\n        &emsp;\r\n        <span className={'bot-score' + (isHumanNext || isGameOver ? '' : ' next-player')}>{`${markerToStr(\r\n          Marker.BOT,\r\n        )} : ${score[1].toString().padStart(2, '0')}`}</span>\r\n        &emsp;\r\n        {isGameOver && <button onClick={newGame}>Reset</button>}\r\n      </p>\r\n      <div id=\"game-board\">\r\n        <Board\r\n          key={boardKey}\r\n          boardWidth={BOARD_WIDTH}\r\n          boardHeight={BOARD_HEIGHT}\r\n          nextPlayer={nextPlayer}\r\n          isGameOver={isGameOver}\r\n          score={score}\r\n          gameIsOver={() => setIsGameOver(true)}\r\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\r\n          updateScore={updateScore}\r\n        />\r\n      </div>\r\n      <p>{gameDialog}</p>\r\n    </div>\r\n  );\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(<Game />, document.getElementById('root'));\r\n"],"sourceRoot":""}