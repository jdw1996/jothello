{"version":3,"sources":["index.tsx"],"names":["Marker","sleep","ms","Promise","v","setTimeout","markerToStr","marker","HUMAN","BOT","getMarker","isHuman","coordToString","coord","stringToCoord","key","ret","split","map","Number","length","Error","cloneBoardArray","board","row","newRow","sc","push","MoveRegion","categorizer","comparator","boardWidth","boardHeight","moves","this","Map","move","wouldFlip","set","bestMove","bestKeyYet","undefined","bestValYet","currentKey","currentVal","getMapMax","get","size","isCorner","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","isInterior","loopOverBoard","modifier","j","i","flippableInDirection","player","flippable","FREE","getValidMoves","nextPlayer","validMoves","_target","concat","flippablePositions","flipped","numFlipped","isHumanMove","newScore","takeMove","position","toFlip","botGo","longestValueComparator","_k1","v1","_k2","v2","shortestValueComparator","moveRegions","flippedPosns","tryAddMove","hasMoves","getBestMove","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","noLongerWouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","score","gameIsOver","otherPlayersTurn","updateScore","useState","width","height","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","useEffect","a","boardClone","endGame","scoreDiff","newValidMoves","target","has","f","handleHover","isEnter","changeToApply","b","bClone","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","setScore","boardKey","setBoardKey","n","diff","s","sClone","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bb014516.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\n  let bestKeyYet = undefined;\n  let bestValYet = undefined;\n  for (const [currentKey, currentVal] of map) {\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\n      bestKeyYet = currentKey;\n      bestValYet = currentVal;\n    }\n  }\n  return bestKeyYet;\n}\n\nfunction sleep(ms: number): Promise<unknown> {\n  return new Promise((v) => setTimeout(v, ms));\n}\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n  noLongerWouldBeFlipped: boolean;\n  justPlaced: boolean;\n  justFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return '👍';\n  } else if (marker === Marker.BOT) {\n    return '🤖';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction otherMarker(marker: Marker): Marker {\n  return getMarker(marker !== Marker.HUMAN);\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n        noLongerWouldBeFlipped: false,\n        justPlaced: false,\n        justFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction cloneBoardArray(board: BoardArray): BoardArray {\n  const ret: BoardArray = [];\n  for (const row of board) {\n    const newRow: SquareContent[] = [];\n    for (const sc of row) {\n      newRow.push({ ...sc });\n    }\n    ret.push(newRow);\n  }\n  return ret;\n}\n\nclass MoveRegion {\n  private categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean;\n  private comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number;\n  private boardWidth: number;\n  private boardHeight: number;\n  private moves: ValidMoves;\n\n  constructor(\n    categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean,\n    comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number,\n    boardWidth: number,\n    boardHeight: number,\n  ) {\n    this.categorizer = categorizer;\n    this.comparator = comparator;\n    this.boardWidth = boardWidth;\n    this.boardHeight = boardHeight;\n    this.moves = new Map<string, Coordinate[]>();\n  }\n\n  tryAddMove(move: string, wouldFlip: Coordinate[]): boolean {\n    if (this.categorizer(stringToCoord(move), this.boardWidth, this.boardHeight) && wouldFlip.length > 0) {\n      this.moves.set(move, wouldFlip);\n      return true;\n    }\n    return false;\n  }\n\n  getBestMove(): [string, Coordinate[]] {\n    const bestMove = getMapMax(this.moves, this.comparator) || '';\n    return [bestMove, this.moves.get(bestMove) || []];\n  }\n\n  hasMoves(): boolean {\n    return this.moves.size > 0;\n  }\n}\n\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\n}\n\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\n  );\n}\n\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) &&\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\n  );\n}\n\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\n  );\n}\n\nfunction isInterior(...args: [Coordinate, number, number]): boolean {\n  return !isCorner(...args) && !isCornerAdjacent(...args) && !isEdge(...args) && !isEdgeAdjacent(...args);\n}\n\nfunction loopOverBoard(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  loopOverBoard(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction flipped(numFlipped: number, isHumanMove: boolean): Score {\n  const newScore: Score = [0, 0];\n  if (numFlipped === 0) {\n    return newScore;\n  }\n  if (isHumanMove) {\n    newScore[0] += 1 + numFlipped;\n    newScore[1] -= numFlipped;\n  } else {\n    newScore[0] -= numFlipped;\n    newScore[1] += 1 + numFlipped;\n  }\n  return newScore;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  // Get the list of possible moves. If none, return.\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n\n  // Sort the moves based on their position on the board.\n  const boardHeight = board.length;\n  const boardWidth = board[0].length;\n  const longestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v2.length - v1.length;\n  const shortestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v1.length - v2.length;\n  const moveRegions: MoveRegion[] = [\n    new MoveRegion(isCorner, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdge, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isInterior, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdgeAdjacent, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isCornerAdjacent, shortestValueComparator, boardWidth, boardHeight),\n  ];\n\n  let move = '';\n  let flippedPosns: Coordinate[] = [];\n  for (const [key] of validMoves) {\n    for (let i = 0; i < moveRegions.length; ++i) {\n      if (moveRegions[i].tryAddMove(key, validMoves.get(key) || [])) {\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < moveRegions.length; ++i) {\n    if (moveRegions[i].hasMoves()) {\n      const bestMove = moveRegions[i].getBestMove();\n      move = bestMove[0];\n      flippedPosns = bestMove[1];\n      if (move) {\n        break;\n      }\n    }\n  }\n  const [x, y] = stringToCoord(move);\n\n  // Modify the board to reflect the chosen move.\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  board[y][x].justPlaced = true;\n  for (const [i, j] of flippedPosns) {\n    board[j][i].justFlipped = true;\n  }\n\n  // Return the number of pieces flipped.\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n  }\n  if (value.noLongerWouldBeFlipped) {\n    cssClasses += ' no-longer-would-be-flipped';\n  }\n  if (value.justPlaced) {\n    cssClasses += ' just-placed';\n  }\n  if (value.justFlipped) {\n    cssClasses += ' just-flipped';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <div className=\"square-container\">\n        <div className=\"square-front\">{markerToStr(value.marker)}</div>\n        <div className=\"square-back\">{markerToStr(otherMarker(value.marker))}</div>\n      </div>\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  score: Score;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (score: Score) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, nextPlayer, isGameOver, score, gameIsOver, otherPlayersTurn, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  useEffect(() => {\n    const f = async () => {\n      // If it's the human's turn or the game is over, do nothing.\n      if (nextPlayer !== Marker.BOT || isGameOver) return;\n\n      const boardClone = cloneBoardArray(board);\n      let endGame = false;\n\n      // Let the bot take its turn.\n      const numFlipped = botGo(boardClone);\n      const scoreDiff = flipped(numFlipped, false);\n\n      // If the bot made a move, wait before persisting changes.\n      await sleep(scoreDiff[0] === 0 && scoreDiff[1] === 0 ? 0 : 500);\n\n      // Find the possible moves for the human.\n      const newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n      if (newValidMoves.size > 0) {\n        // If the human can go, it is their turn.\n        otherPlayersTurn();\n        // Mark valid moves on the board.\n        loopOverBoard(boardClone, (target, x, y) => {\n          target.isValidMove = newValidMoves.has(coordToString([x, y]));\n        });\n      } else if (numFlipped === 0) {\n        // If the human can't go and the bot passed, the game is over.\n        endGame = true;\n      }\n\n      endGame && gameIsOver();\n      setBoard(boardClone);\n      setValidMoves(newValidMoves);\n      updateScore(scoreDiff);\n    };\n    f();\n  }, [score]);\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = cloneBoardArray(board);\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    const scoreDiff = flipped(validMoves.get(currentKey)?.length || 0, true);\n\n    // Clear data about what happened previously.\n    loopOverBoard(boardClone, (target) => {\n      target.isValidMove = false;\n      target.wouldBeFlipped = false;\n      target.justPlaced = false;\n      target.justFlipped = false;\n      target.noLongerWouldBeFlipped = false;\n    });\n\n    // End turn and persist board changes, new set of valid moves, and new score.\n    otherPlayersTurn();\n    setBoard(boardClone);\n    setValidMoves(new Map<string, Coordinate[]>());\n    updateScore(scoreDiff);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const changeToApply = isEnter\n      ? (sc: SquareContent) => {\n          sc.wouldBeFlipped = true;\n          sc.noLongerWouldBeFlipped = false;\n        }\n      : (sc: SquareContent) => {\n          sc.wouldBeFlipped = false;\n          sc.noLongerWouldBeFlipped = true;\n        };\n    setBoard((b) => {\n      const bClone = cloneBoardArray(b);\n      for (const [i, j] of validMoves.get(currentKey) || []) {\n        changeToApply(bClone[j][i]);\n      }\n      return bClone;\n    });\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n  const [boardKey, setBoardKey] = useState(0);\n\n  function updateScore(diff: Score): void {\n    setScore((s) => {\n      const sClone: Score = [...s];\n      sClone[0] += diff[0];\n      sClone[1] += diff[1];\n      return sClone;\n    });\n  }\n\n  function newGame(): void {\n    setIsHumanNext(true);\n    setIsGameOver(false);\n    setScore([2, 2]);\n    setBoardKey((n) => n + 1);\n  }\n\n  return (\n    <div className=\"game\">\n      <p className=\"status\">\n        {isGameOver ? (\n          <>\n            Game over. <button onClick={newGame}>Reset</button>\n          </>\n        ) : (\n          `Next player: ${markerToStr(nextPlayer)}\\n`\n        )}\n      </p>\n      <p className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</p>\n      <div className=\"game-board\">\n        <Board\n          key={boardKey}\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          score={score}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}