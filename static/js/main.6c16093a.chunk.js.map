{"version":3,"sources":["index.tsx"],"names":["Marker","markerToStr","marker","HUMAN","BOT","coordToString","coord","stringToCoord","key","ret","split","map","Number","length","Error","modifySquareContents","board","modifier","j","i","flippableInDirection","x","y","player","flippable","FREE","push","getValidMoves","nextPlayer","validMoves","Map","_target","concat","flippablePositions","set","flipped","currentScore","numFlipped","isHumanMove","newScore","takeMove","position","toFlip","botGo","size","move","flippedPosns","get","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","boardWidth","boardHeight","isGameOver","gameIsOver","updateScore","useState","width","height","row","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","handleHover","isEnter","currentKey","has","boardClone","slice","sc","scoreDiff","newValidMoves","botPassed","target","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","score","setScore","otherPlayersTurn","diff","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.6c16093a.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return 'üëç';\n  } else if (marker === Marker.BOT) {\n    return 'ü§ñ';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction modifySquareContents(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  modifySquareContents(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction flipped(currentScore: Score, numFlipped: number, isHumanMove: boolean): Score {\n  const newScore: Score = [...currentScore];\n  if (isHumanMove) {\n    newScore[0] += 1 + numFlipped;\n    newScore[1] -= numFlipped;\n  } else {\n    newScore[0] -= numFlipped;\n    newScore[1] += 1 + numFlipped;\n  }\n  return newScore;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n  let move = '';\n  for (const [key] of validMoves) {\n    move = key;\n    break;\n  }\n  const [x, y] = stringToCoord(move);\n  const flippedPosns: Coordinate[] = validMoves.get(move) || [];\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-human-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped-human';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      {markerToStr(value.marker)}\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (score: Score) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, isGameOver, gameIsOver, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = board.slice();\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    let scoreDiff = flipped([0, 0], validMoves.get(currentKey)?.length || 0, true);\n\n    let newValidMoves: ValidMoves = validMoves;\n    let botPassed = false;\n    do {\n      // Let the bot take its turn.\n      const numFlipped = botGo(boardClone);\n      botPassed = numFlipped === 0;\n      if (numFlipped > 0) {\n        scoreDiff = flipped(scoreDiff, numFlipped, false);\n      }\n\n      // Determine whether there are any valid moves for humans; if there\n      // aren't and the bot passed, then the game is over.\n      newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n      if (newValidMoves.size === 0 && botPassed) {\n        gameIsOver();\n      }\n\n      // If the bot went and the human cannot go, the bot can go again.\n    } while (newValidMoves.size === 0 && !botPassed);\n\n    // Reset the valid moves marked on the board.\n    modifySquareContents(boardClone, (target, x, y) => {\n      target.isValidMove = newValidMoves.has(coordToString([x, y]));\n      target.wouldBeFlipped = false;\n    });\n\n    // Persist the board changes, the new set of valid moves, and the new score.\n    setBoard(boardClone);\n    setValidMoves(newValidMoves);\n    updateScore(scoreDiff);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const boardClone = board.slice();\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      boardClone[j][i].wouldBeFlipped = isEnter;\n    }\n    setBoard(boardClone);\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n\n  function updateScore(diff: Score): void {\n    const newScore: Score = [...score];\n    newScore[0] += diff[0];\n    newScore[1] += diff[1];\n    setScore(newScore);\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"status\">{isGameOver ? 'Game over.\\n' : `Next player: ${markerToStr(nextPlayer)}\\n`}</div>\n      <div className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</div>\n      <div className=\"game-board\">\n        <Board\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}