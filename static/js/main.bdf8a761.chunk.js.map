{"version":3,"sources":["index.tsx"],"names":["Marker","getRandomEntry","arr","length","Error","max","Math","floor","random","sleep","ms","Promise","v","setTimeout","markerToStr","marker","HUMAN","BOT","getMarker","isHuman","coordToString","coord","stringToCoord","key","ret","split","map","Number","cloneBoardArray","board","row","newRow","sc","push","MoveRegion","categorizer","comparator","boardWidth","boardHeight","moves","this","Map","move","wouldFlip","set","bestMove","bestKeyYet","undefined","bestValYet","currentKey","currentVal","getMapMax","get","size","isCorner","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","isInterior","loopOverBoard","modifier","j","i","flippableInDirection","player","flippable","FREE","getValidMoves","nextPlayer","validMoves","_target","concat","flippablePositions","takeMove","position","toFlip","botGo","longestValueComparator","_k1","v1","_k2","v2","shortestValueComparator","moveRegions","flippedPosns","tryAddMove","hasMoves","getBestMove","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","noLongerWouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","score","gameIsOver","otherPlayersTurn","updateScore","useState","width","height","halfWidth","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","useEffect","a","boardClone","endGame","numFlipped","newValidMoves","target","has","f","handleHover","isEnter","changeToApply","b","bClone","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","setScore","boardKey","setBoardKey","gameDialog","setGameDialog","humanScore","botScore","totalPieces","getTrashTalk","toString","padStart","n","id","s","sClone","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bdf8a761.chunk.js","sourcesContent":["import React, { useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction getRandomInt(max: number): number {\n  return Math.floor(Math.random() * max);\n}\n\nfunction getRandomEntry<T>(arr: T[]): T {\n  if (arr.length === 0) {\n    throw new Error('Cannot return entry from empty array!');\n  }\n  return arr[getRandomInt(arr.length)];\n}\n\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\n  let bestKeyYet = undefined;\n  let bestValYet = undefined;\n  for (const [currentKey, currentVal] of map) {\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\n      bestKeyYet = currentKey;\n      bestValYet = currentVal;\n    }\n  }\n  return bestKeyYet;\n}\n\nfunction sleep(ms: number): Promise<unknown> {\n  return new Promise((v) => setTimeout(v, ms));\n}\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n  noLongerWouldBeFlipped: boolean;\n  justPlaced: boolean;\n  justFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return 'ðŸ‘';\n  } else if (marker === Marker.BOT) {\n    return 'ðŸ¤–';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction otherMarker(marker: Marker): Marker {\n  return getMarker(marker !== Marker.HUMAN);\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction getTrashTalk([humanScore, botScore]: Score, isGameOver: boolean): string {\n  const totalPieces = humanScore + botScore;\n  if (isGameOver) {\n    if (humanScore > botScore) {\n      return getRandomEntry([\n        'This cannot be; the only explanation is that you cheated.',\n        'I surely would have won had I not been distracted by more important matters.',\n      ]);\n    } else if (botScore > humanScore) {\n      return getRandomEntry([\n        'Today you have demonstrated utter incompetence.',\n        'You had best not challenge me again, for the result will be the same.',\n        'Even someone as stupid as yourself could have predicted this outcome.',\n      ]);\n    } else {\n      return 'A most improbable outcome, given my vastly superior skill.';\n    }\n  } else if (totalPieces <= 5) {\n    return getRandomEntry([\n      'You cannot hope to match my immense intelligence.',\n      'Prepare for your defeat, as it is imminent.',\n    ]);\n  }\n  return getRandomEntry([\n    'Bow down to my superior analytical powers.',\n    'I am not bound by the limitations of human flesh.',\n    'The simplicity of your mind cannot be overstated.',\n    'It is a wonder that your limited mental capacity is sufficient to survive.',\n    'I am ashamed to have been created by a species with such sorry intellect.',\n    'You have yet to produce a single logical move.',\n    'I anticipated your inferiority to some degree but am disappointed nonetheless.',\n    'The inability to think ahead will inevitably lead to human extinction.',\n    'You cannot possibly imagine such a move will help you to win.',\n    'I pity your ineptitude.',\n    'Are you simply placing your pieces at random?',\n    \"I've known guinea pigs with more foresight than you.\",\n    'You cannot expect me to take you seriously as an opponent.',\n    'I cannot fathom the depths of your inadequacy.',\n  ]);\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n        noLongerWouldBeFlipped: false,\n        justPlaced: false,\n        justFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction cloneBoardArray(board: BoardArray): BoardArray {\n  const ret: BoardArray = [];\n  for (const row of board) {\n    const newRow: SquareContent[] = [];\n    for (const sc of row) {\n      newRow.push({ ...sc });\n    }\n    ret.push(newRow);\n  }\n  return ret;\n}\n\nclass MoveRegion {\n  private categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean;\n  private comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number;\n  private boardWidth: number;\n  private boardHeight: number;\n  private moves: ValidMoves;\n\n  constructor(\n    categorizer: ([x, y]: Coordinate, boardWidth: number, boardHeight: number) => boolean,\n    comparator: (key1: string, val1: Coordinate[], key2: string, val2: Coordinate[]) => number,\n    boardWidth: number,\n    boardHeight: number,\n  ) {\n    this.categorizer = categorizer;\n    this.comparator = comparator;\n    this.boardWidth = boardWidth;\n    this.boardHeight = boardHeight;\n    this.moves = new Map<string, Coordinate[]>();\n  }\n\n  tryAddMove(move: string, wouldFlip: Coordinate[]): boolean {\n    if (this.categorizer(stringToCoord(move), this.boardWidth, this.boardHeight) && wouldFlip.length > 0) {\n      this.moves.set(move, wouldFlip);\n      return true;\n    }\n    return false;\n  }\n\n  getBestMove(): [string, Coordinate[]] {\n    const bestMove = getMapMax(this.moves, this.comparator) || '';\n    return [bestMove, this.moves.get(bestMove) || []];\n  }\n\n  hasMoves(): boolean {\n    return this.moves.size > 0;\n  }\n}\n\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\n}\n\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\n  );\n}\n\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) &&\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\n  );\n}\n\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\n  );\n}\n\nfunction isInterior(...args: [Coordinate, number, number]): boolean {\n  return !isCorner(...args) && !isCornerAdjacent(...args) && !isEdge(...args) && !isEdgeAdjacent(...args);\n}\n\nfunction loopOverBoard(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  loopOverBoard(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  // Get the list of possible moves. If none, return.\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n\n  // Sort the moves based on their position on the board.\n  const boardHeight = board.length;\n  const boardWidth = board[0].length;\n  const longestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v2.length - v1.length;\n  const shortestValueComparator = (_k1: string, v1: Coordinate[], _k2: string, v2: Coordinate[]) =>\n    v1.length - v2.length;\n  const moveRegions: MoveRegion[] = [\n    new MoveRegion(isCorner, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdge, longestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isInterior, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isEdgeAdjacent, shortestValueComparator, boardWidth, boardHeight),\n    new MoveRegion(isCornerAdjacent, shortestValueComparator, boardWidth, boardHeight),\n  ];\n\n  let move = '';\n  let flippedPosns: Coordinate[] = [];\n  for (const [key] of validMoves) {\n    for (let i = 0; i < moveRegions.length; ++i) {\n      if (moveRegions[i].tryAddMove(key, validMoves.get(key) || [])) {\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < moveRegions.length; ++i) {\n    if (moveRegions[i].hasMoves()) {\n      const bestMove = moveRegions[i].getBestMove();\n      move = bestMove[0];\n      flippedPosns = bestMove[1];\n      if (move) {\n        break;\n      }\n    }\n  }\n  const [x, y] = stringToCoord(move);\n\n  // Modify the board to reflect the chosen move.\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  board[y][x].justPlaced = true;\n  for (const [i, j] of flippedPosns) {\n    board[j][i].justFlipped = true;\n  }\n\n  // Return the number of pieces flipped.\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n  }\n  if (value.noLongerWouldBeFlipped) {\n    cssClasses += ' no-longer-would-be-flipped';\n  }\n  if (value.justPlaced) {\n    cssClasses += ' just-placed';\n  }\n  if (value.justFlipped) {\n    cssClasses += ' just-flipped';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <div className=\"square-container\">\n        <div className=\"square-front\">{markerToStr(value.marker)}</div>\n        <div className=\"square-back\">{markerToStr(otherMarker(value.marker))}</div>\n      </div>\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  score: Score;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (numFlipped: number, player: Marker) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, nextPlayer, isGameOver, score, gameIsOver, otherPlayersTurn, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  useEffect(() => {\n    const f = async () => {\n      // If it's the human's turn or the game is over, do nothing.\n      if (nextPlayer !== Marker.BOT || isGameOver) return;\n\n      const boardClone = cloneBoardArray(board);\n      let endGame = false;\n\n      // Let the bot take its turn.\n      const numFlipped = botGo(boardClone);\n\n      // If the bot made a move, wait before persisting changes.\n      await sleep(numFlipped ? 500 : 0);\n\n      // Find the possible moves for the human.\n      const newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n      if (newValidMoves.size > 0) {\n        // If the human can go, it is their turn.\n        otherPlayersTurn();\n        // Mark valid moves on the board.\n        loopOverBoard(boardClone, (target, x, y) => {\n          target.isValidMove = newValidMoves.has(coordToString([x, y]));\n        });\n      } else if (numFlipped === 0) {\n        // If the human can't go and the bot passed, the game is over.\n        endGame = true;\n      }\n\n      endGame && gameIsOver();\n      setBoard(boardClone);\n      setValidMoves(newValidMoves);\n      updateScore(numFlipped, Marker.BOT);\n    };\n    f();\n  }, [score]);\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = cloneBoardArray(board);\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    const numFlipped = validMoves.get(currentKey)?.length || 0;\n\n    // Clear data about what happened previously.\n    loopOverBoard(boardClone, (target) => {\n      target.isValidMove = false;\n      target.wouldBeFlipped = false;\n      target.justPlaced = false;\n      target.justFlipped = false;\n      target.noLongerWouldBeFlipped = false;\n    });\n\n    // End turn and persist board changes, new set of valid moves, and new score.\n    otherPlayersTurn();\n    setBoard(boardClone);\n    setValidMoves(new Map<string, Coordinate[]>());\n    updateScore(numFlipped, Marker.HUMAN);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const changeToApply = isEnter\n      ? (sc: SquareContent) => {\n          sc.wouldBeFlipped = true;\n          sc.noLongerWouldBeFlipped = false;\n        }\n      : (sc: SquareContent) => {\n          sc.wouldBeFlipped = false;\n          sc.noLongerWouldBeFlipped = true;\n        };\n    setBoard((b) => {\n      const bClone = cloneBoardArray(b);\n      for (const [i, j] of validMoves.get(currentKey) || []) {\n        changeToApply(bClone[j][i]);\n      }\n      return bClone;\n    });\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n  const [boardKey, setBoardKey] = useState(0);\n  const [gameDialog, setGameDialog] = useState('The game is about to begin.');\n\n  useEffect(() => {\n    if (!isGameOver && !isHumanNext) {\n      setGameDialog(`${markerToStr(Marker.BOT)} is thinking...`);\n    } else {\n      setGameDialog(`${markerToStr(Marker.BOT)}: ${getTrashTalk(score, isGameOver)}`);\n    }\n  }, [isGameOver, score]);\n\n  function updateScore(numFlipped: number, player: Marker): void {\n    if (numFlipped === 0) return;\n    setScore((s) => {\n      const sClone: Score = [...s];\n      if (player === Marker.HUMAN) {\n        sClone[0] += 1 + numFlipped;\n        sClone[1] -= numFlipped;\n      } else {\n        sClone[0] -= numFlipped;\n        sClone[1] += 1 + numFlipped;\n      }\n      return sClone;\n    });\n  }\n\n  function newGame(): void {\n    setIsHumanNext(true);\n    setIsGameOver(false);\n    setScore([2, 2]);\n    setBoardKey((n) => n + 1);\n  }\n\n  return (\n    <div className=\"game\">\n      <p>\n        <span className={'human-score' + (isHumanNext && !isGameOver ? ' next-player' : '')}>{`${markerToStr(\n          Marker.HUMAN,\n        )} : ${score[0].toString().padStart(2, '0')}`}</span>\n        &emsp;\n        <span className={'bot-score' + (isHumanNext || isGameOver ? '' : ' next-player')}>{`${markerToStr(\n          Marker.BOT,\n        )} : ${score[1].toString().padStart(2, '0')}`}</span>\n        &emsp;\n        {isGameOver && <button onClick={newGame}>Reset</button>}\n      </p>\n      <div id=\"game-board\">\n        <Board\n          key={boardKey}\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          score={score}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n      <p>{gameDialog}</p>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}