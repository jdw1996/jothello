{"version":3,"sources":["index.tsx"],"names":["Marker","getMapMax","map","comparator","bestKeyYet","undefined","bestValYet","currentKey","currentVal","markerToStr","marker","HUMAN","BOT","getMarker","isHuman","coordToString","coord","stringToCoord","key","ret","split","Number","length","Error","isCorner","boardWidth","boardHeight","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","modifySquareContents","board","modifier","j","i","flippableInDirection","player","flippable","FREE","push","getValidMoves","nextPlayer","validMoves","Map","_target","concat","flippablePositions","set","flipped","currentScore","numFlipped","isHumanMove","newScore","takeMove","position","toFlip","botGo","size","move","corners","cornerAdjacent","edges","edgeAdjacent","interior","checkingArgs","settingArgs","get","_k1","v1","_k2","v2","flippedPosns","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","noLongerWouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","gameIsOver","otherPlayersTurn","updateScore","useState","width","height","row","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","setTimeout","boardClone","slice","newValidMoves","botPassed","scoreDiff","target","has","handleHover","isEnter","changeToApply","sc","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","score","setScore","diff","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.7301c11a.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\n  let bestKeyYet = undefined;\n  let bestValYet = undefined;\n  for (const [currentKey, currentVal] of map) {\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\n      bestKeyYet = currentKey;\n      bestValYet = currentVal;\n    }\n  }\n  return bestKeyYet;\n}\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n  noLongerWouldBeFlipped: boolean;\n  justPlaced: boolean;\n  justFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return '👍';\n  } else if (marker === Marker.BOT) {\n    return '🤖';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction otherMarker(marker: Marker): Marker {\n  return getMarker(marker !== Marker.HUMAN);\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n        noLongerWouldBeFlipped: false,\n        justPlaced: false,\n        justFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\n}\n\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\n  );\n}\n\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\n  );\n}\n\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\n  );\n}\n\nfunction modifySquareContents(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  modifySquareContents(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction flipped(currentScore: Score, numFlipped: number, isHumanMove: boolean): Score {\n  const newScore: Score = [...currentScore];\n  if (isHumanMove) {\n    newScore[0] += 1 + numFlipped;\n    newScore[1] -= numFlipped;\n  } else {\n    newScore[0] -= numFlipped;\n    newScore[1] += 1 + numFlipped;\n  }\n  return newScore;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  // Get the list of possible moves. If none, return.\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n\n  // Sort the moves based on their position on the board.\n  let move = '';\n  const boardHeight = board.length;\n  const boardWidth = board[0].length;\n  const corners = new Map<string, Coordinate[]>();\n  const cornerAdjacent = new Map<string, Coordinate[]>();\n  const edges = new Map<string, Coordinate[]>();\n  const edgeAdjacent = new Map<string, Coordinate[]>();\n  const interior = new Map<string, Coordinate[]>();\n  for (const [key] of validMoves) {\n    const checkingArgs: [Coordinate, number, number] = [stringToCoord(key), boardWidth, boardHeight];\n    const settingArgs: [string, Coordinate[]] = [key, validMoves.get(key) || []];\n    if (isCorner(...checkingArgs)) {\n      corners.set(...settingArgs);\n    } else if (isCornerAdjacent(...checkingArgs)) {\n      cornerAdjacent.set(...settingArgs);\n    } else if (isEdge(...checkingArgs)) {\n      edges.set(...settingArgs);\n    } else if (isEdgeAdjacent(...checkingArgs)) {\n      edgeAdjacent.set(...settingArgs);\n    } else {\n      interior.set(...settingArgs);\n    }\n  }\n  if (corners.size > 0) {\n    // If any corner moves are available, choose the one that flips the most\n    // pieces.\n    move = getMapMax(corners, (_k1, v1, _k2, v2) => v2.length - v1.length) || move;\n  } else if (edges.size > 0) {\n    // If any edge moves are available, choose the one that flips the most\n    // pieces.\n    move = getMapMax(edges, (_k1, v1, _k2, v2) => v2.length - v1.length) || move;\n  } else if (interior.size > 0) {\n    // If any interior moves are available, choose the one that flips the fewest\n    // pieces.\n    move = getMapMax(interior, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  } else if (edgeAdjacent.size > 0) {\n    // If any edge-adjacent moves are available, choose the one that flips the\n    // fewest pieces.\n    move = getMapMax(edgeAdjacent, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  } else {\n    // If only corner-adjacent moves are available, choose the one that flips\n    // the fewest pieces.\n    move = getMapMax(cornerAdjacent, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  }\n  const [x, y] = stringToCoord(move);\n\n  // Modify the board to reflect the chosen move.\n  const flippedPosns: Coordinate[] = validMoves.get(move) || [];\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  board[y][x].justPlaced = true;\n  for (const [i, j] of flippedPosns) {\n    board[j][i].justFlipped = true;\n  }\n\n  // Return the number of pieces flipped.\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n  }\n  if (value.noLongerWouldBeFlipped) {\n    cssClasses += ' no-longer-would-be-flipped';\n  }\n  if (value.justPlaced) {\n    cssClasses += ' just-placed';\n  }\n  if (value.justFlipped) {\n    cssClasses += ' just-flipped';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      <div className=\"square-container\">\n        <div className=\"square-front\">{markerToStr(value.marker)}</div>\n        <div className=\"square-back\">{markerToStr(otherMarker(value.marker))}</div>\n      </div>\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (score: Score) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, nextPlayer, isGameOver, gameIsOver, otherPlayersTurn, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  if (nextPlayer === Marker.BOT && !isGameOver) {\n    setTimeout(() => {\n      const boardClone = board.slice();\n      let newValidMoves: ValidMoves = new Map<string, Coordinate[]>();\n      let botPassed = false;\n      let scoreDiff: [number, number] = [0, 0];\n      do {\n        // Let the bot take its turn.\n        const numFlipped = botGo(boardClone);\n        botPassed = numFlipped === 0;\n        if (numFlipped > 0) {\n          scoreDiff = flipped(scoreDiff, numFlipped, false);\n        }\n\n        // Determine whether there are any valid moves for humans; if there\n        // aren't and the bot passed, then the game is over.\n        newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n        if (newValidMoves.size === 0 && botPassed) {\n          gameIsOver();\n        }\n\n        // If the bot went and the human cannot go, the bot can go again.\n      } while (newValidMoves.size === 0 && !botPassed);\n\n      // Mark valid moves on the board.\n      modifySquareContents(boardClone, (target, x, y) => {\n        target.isValidMove = newValidMoves.has(coordToString([x, y]));\n      });\n\n      // End turn and persist board changes, new set of valid moves, and new score.\n      otherPlayersTurn();\n      setBoard(boardClone);\n      setValidMoves(newValidMoves);\n      updateScore(scoreDiff);\n    }, 500);\n  }\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = board.slice();\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    const scoreDiff = flipped([0, 0], validMoves.get(currentKey)?.length || 0, true);\n\n    // Clear data about what happened previously.\n    modifySquareContents(boardClone, (target) => {\n      target.isValidMove = false;\n      target.wouldBeFlipped = false;\n      target.justPlaced = false;\n      target.justFlipped = false;\n      target.noLongerWouldBeFlipped = false;\n    });\n\n    // End turn and persist board changes, new set of valid moves, and new score.\n    otherPlayersTurn();\n    setBoard(boardClone);\n    setValidMoves(new Map<string, Coordinate[]>());\n    updateScore(scoreDiff);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const boardClone = board.slice();\n    const changeToApply = isEnter\n      ? (sc: SquareContent) => {\n          sc.wouldBeFlipped = true;\n          sc.noLongerWouldBeFlipped = false;\n        }\n      : (sc: SquareContent) => {\n          sc.wouldBeFlipped = false;\n          sc.noLongerWouldBeFlipped = true;\n        };\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      changeToApply(boardClone[j][i]);\n    }\n    setBoard(boardClone);\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n\n  function updateScore(diff: Score): void {\n    const newScore: Score = [...score];\n    newScore[0] += diff[0];\n    newScore[1] += diff[1];\n    setScore(newScore);\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"status\">{isGameOver ? 'Game over.\\n' : `Next player: ${markerToStr(nextPlayer)}\\n`}</div>\n      <div className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</div>\n      <div className=\"game-board\">\n        <Board\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}