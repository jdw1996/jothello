{"version":3,"sources":["index.tsx"],"names":["Marker","getMapMax","map","comparator","bestKeyYet","undefined","bestValYet","currentKey","currentVal","markerToStr","marker","HUMAN","BOT","coordToString","coord","stringToCoord","key","ret","split","Number","length","Error","isCorner","boardWidth","boardHeight","x","y","isCornerAdjacent","isEdge","isEdgeAdjacent","modifySquareContents","board","modifier","j","i","flippableInDirection","player","flippable","FREE","push","getValidMoves","nextPlayer","validMoves","Map","_target","concat","flippablePositions","set","flipped","currentScore","numFlipped","isHumanMove","newScore","takeMove","position","toFlip","botGo","size","move","corners","cornerAdjacent","edges","edgeAdjacent","interior","checkingArgs","settingArgs","get","_k1","v1","_k2","v2","flippedPosns","justPlaced","justFlipped","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","isGameOver","gameIsOver","updateScore","useState","width","height","row","halfWidth","Math","floor","halfHeight","forEach","_v","k","createBoardArray","setBoard","setValidMoves","handleHover","isEnter","has","boardClone","slice","sc","scoreDiff","target","newValidMoves","botPassed","handleBoardClick","Game","isHumanNext","setIsHumanNext","setIsGameOver","score","setScore","otherPlayersTurn","diff","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.bb808df7.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nfunction getMapMax<K, V>(map: Map<K, V>, comparator: (key1: K, val1: V, key2: K, val2: V) => number): K | undefined {\n  let bestKeyYet = undefined;\n  let bestValYet = undefined;\n  for (const [currentKey, currentVal] of map) {\n    if (!bestKeyYet || !bestValYet || comparator(bestKeyYet, bestValYet, currentKey, currentVal) > 0) {\n      bestKeyYet = currentKey;\n      bestValYet = currentVal;\n    }\n  }\n  return bestKeyYet;\n}\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\ntype SquareContent = {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n  justPlaced: boolean;\n  justFlipped: boolean;\n};\ntype BoardArray = SquareContent[][];\ntype Score = [number, number];\ntype Coordinate = [number, number];\ntype ValidMoves = Map<string, Coordinate[]>;\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return 'üëç';\n  } else if (marker === Marker.BOT) {\n    return 'ü§ñ';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction coordToString(coord: Coordinate): string {\n  return `${coord[0]},${coord[1]}`;\n}\n\nfunction stringToCoord(key: string): Coordinate {\n  const ret = key.split(',').map(Number);\n  if (ret.length === 2) return ret as Coordinate;\n  throw new Error('Cannot convert given string to Coordinate!');\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): BoardArray {\n  const ret: BoardArray = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n        justPlaced: false,\n        justFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = stringToCoord(k);\n    ret[y][x].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction isCorner([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (x === 0 || x === boardWidth - 1) && (y === 0 || y === boardHeight - 1);\n}\n\nfunction isCornerAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x <= 1 || x >= boardWidth - 2) && (y <= 1 || y >= boardHeight - 2)\n  );\n}\n\nfunction isEdge([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCorner([x, y], boardHeight, boardWidth) && (x === 0 || x === boardWidth - 1 || y === 0 || y === boardHeight - 1)\n  );\n}\n\nfunction isEdgeAdjacent([x, y]: Coordinate, boardWidth: number, boardHeight: number): boolean {\n  return (\n    !isCornerAdjacent([x, y], boardHeight, boardWidth) &&\n    (x === 1 || x === boardWidth - 2 || y === 1 || y === boardHeight - 2)\n  );\n}\n\nfunction modifySquareContents(board: BoardArray, modifier: (target: SquareContent, i: number, j: number) => void) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: BoardArray,\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): Coordinate[] {\n  const flippable: Coordinate[] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: BoardArray, x: number, y: number, player: Marker): Coordinate[] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: Coordinate[] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(board: BoardArray, nextPlayer: Marker): ValidMoves {\n  const validMoves: ValidMoves = new Map<string, Coordinate[]>();\n  modifySquareContents(board, (_target, x, y) => {\n    const flippable = flippablePositions(board, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(coordToString([x, y]), flippable);\n    }\n  });\n  return validMoves;\n}\n\nfunction flipped(currentScore: Score, numFlipped: number, isHumanMove: boolean): Score {\n  const newScore: Score = [...currentScore];\n  if (isHumanMove) {\n    newScore[0] += 1 + numFlipped;\n    newScore[1] -= numFlipped;\n  } else {\n    newScore[0] -= numFlipped;\n    newScore[1] += 1 + numFlipped;\n  }\n  return newScore;\n}\n\nfunction takeMove(board: BoardArray, player: Marker, position: Coordinate, toFlip: Coordinate[]): void {\n  board[position[1]][position[0]].marker = player;\n  for (const [i, j] of toFlip) {\n    board[j][i].marker = player;\n  }\n}\n\nfunction botGo(board: BoardArray): number {\n  // Get the list of possible moves. If none, return.\n  const validMoves = getValidMoves(board, Marker.BOT);\n  if (validMoves.size === 0) return 0;\n\n  // Sort the moves based on their position on the board.\n  let move = '';\n  const boardHeight = board.length;\n  const boardWidth = board[0].length;\n  const corners = new Map<string, Coordinate[]>();\n  const cornerAdjacent = new Map<string, Coordinate[]>();\n  const edges = new Map<string, Coordinate[]>();\n  const edgeAdjacent = new Map<string, Coordinate[]>();\n  const interior = new Map<string, Coordinate[]>();\n  for (const [key] of validMoves) {\n    const checkingArgs: [Coordinate, number, number] = [stringToCoord(key), boardWidth, boardHeight];\n    const settingArgs: [string, Coordinate[]] = [key, validMoves.get(key) || []];\n    if (isCorner(...checkingArgs)) {\n      corners.set(...settingArgs);\n    } else if (isCornerAdjacent(...checkingArgs)) {\n      cornerAdjacent.set(...settingArgs);\n    } else if (isEdge(...checkingArgs)) {\n      edges.set(...settingArgs);\n    } else if (isEdgeAdjacent(...checkingArgs)) {\n      edgeAdjacent.set(...settingArgs);\n    } else {\n      interior.set(...settingArgs);\n    }\n  }\n  if (corners.size > 0) {\n    // If any corner moves are available, choose the one that flips the most\n    // pieces.\n    move = getMapMax(corners, (_k1, v1, _k2, v2) => v2.length - v1.length) || move;\n  } else if (edges.size > 0) {\n    // If any edge moves are available, choose the one that flips the most\n    // pieces.\n    move = getMapMax(edges, (_k1, v1, _k2, v2) => v2.length - v1.length) || move;\n  } else if (interior.size > 0) {\n    // If any interior moves are available, choose the one that flips the fewest\n    // pieces.\n    move = getMapMax(interior, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  } else if (edgeAdjacent.size > 0) {\n    // If any edge-adjacent moves are available, choose the one that flips the\n    // fewest pieces.\n    move = getMapMax(edgeAdjacent, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  } else {\n    // If only corner-adjacent moves are available, choose the one that flips\n    // the fewest pieces.\n    move = getMapMax(cornerAdjacent, (_k1, v1, _k2, v2) => v1.length - v2.length) || move;\n  }\n  const [x, y] = stringToCoord(move);\n\n  // Modify the board to reflect the chosen move.\n  const flippedPosns: Coordinate[] = validMoves.get(move) || [];\n  takeMove(board, Marker.BOT, [x, y], flippedPosns);\n  board[y][x].justPlaced = true;\n  for (const [i, j] of flippedPosns) {\n    board[j][i].justFlipped = true;\n  }\n\n  // Return the number of pieces flipped.\n  return flippedPosns.length;\n}\n\ntype SquareProps = {\n  value: SquareContent;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n};\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n  }\n  if (value.justPlaced) {\n    cssClasses += ' just-placed';\n  }\n  if (value.justFlipped) {\n    cssClasses += ' just-flipped';\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      {markerToStr(value.marker)}\n    </td>\n  );\n}\n\ntype BoardProps = {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  isGameOver: boolean;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n  updateScore: (score: Score) => void;\n};\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, isGameOver, gameIsOver, updateScore } = props;\n  const [board, setBoard] = useState(createBoardArray(boardWidth, boardHeight, Marker.HUMAN));\n  const [validMoves, setValidMoves] = useState(getValidMoves(board, Marker.HUMAN));\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardClone = board.slice();\n    takeMove(boardClone, Marker.HUMAN, [x, y], validMoves.get(currentKey) || []);\n    let scoreDiff = flipped([0, 0], validMoves.get(currentKey)?.length || 0, true);\n\n    // Clear data about what the bot did previously.\n    modifySquareContents(boardClone, (target) => {\n      target.justPlaced = false;\n      target.justFlipped = false;\n    });\n\n    let newValidMoves: ValidMoves = validMoves;\n    let botPassed = false;\n    do {\n      // Let the bot take its turn.\n      const numFlipped = botGo(boardClone);\n      botPassed = numFlipped === 0;\n      if (numFlipped > 0) {\n        scoreDiff = flipped(scoreDiff, numFlipped, false);\n      }\n\n      // Determine whether there are any valid moves for humans; if there\n      // aren't and the bot passed, then the game is over.\n      newValidMoves = getValidMoves(boardClone, Marker.HUMAN);\n      if (newValidMoves.size === 0 && botPassed) {\n        gameIsOver();\n      }\n\n      // If the bot went and the human cannot go, the bot can go again.\n    } while (newValidMoves.size === 0 && !botPassed);\n\n    // Reset the valid moves marked on the board.\n    modifySquareContents(boardClone, (target, x, y) => {\n      target.isValidMove = newValidMoves.has(coordToString([x, y]));\n      target.wouldBeFlipped = false;\n    });\n\n    // Persist the board changes, the new set of valid moves, and the new score.\n    setBoard(boardClone);\n    setValidMoves(newValidMoves);\n    updateScore(scoreDiff);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = coordToString([x, y]);\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const boardClone = board.slice();\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      boardClone[j][i].wouldBeFlipped = isEnter;\n    }\n    setBoard(boardClone);\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {board.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={coordToString([x, y])}\n                  value={sc}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState<Score>([2, 2]);\n\n  function updateScore(diff: Score): void {\n    const newScore: Score = [...score];\n    newScore[0] += diff[0];\n    newScore[1] += diff[1];\n    setScore(newScore);\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"status\">{isGameOver ? 'Game over.\\n' : `Next player: ${markerToStr(nextPlayer)}\\n`}</div>\n      <div className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</div>\n      <div className=\"game-board\">\n        <Board\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          updateScore={updateScore}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}