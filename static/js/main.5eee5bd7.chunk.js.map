{"version":3,"sources":["index.tsx"],"names":["Marker","markerToStr","marker","HUMAN","BOT","modifySquareContents","board","modifier","j","length","i","flippableInDirection","x","y","player","flippable","FREE","push","getValidMoves","boardArray","nextPlayer","validMoves","Map","_target","concat","flippablePositions","set","Square","props","value","onClick","handleMouseEnter","handleMouseLeave","cssClasses","isValidMove","wouldBeFlipped","className","onMouseEnter","onMouseLeave","Board","boardWidth","boardHeight","flipped","isGameOver","gameIsOver","otherPlayersTurn","useState","width","height","ret","row","halfWidth","Math","floor","halfHeight","forEach","_v","k","split","Number","createBoardArray","setBoardArray","setValidMoves","handleBoardClick","currentKey","has","boardArrayClone","slice","get","newValidMoves","size","target","handleHover","isEnter","map","key","sc","Game","isHumanNext","setIsHumanNext","setIsGameOver","score","setScore","numFlipped","newScore","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5eee5bd7.chunk.js","sourcesContent":["import React, { useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\nenum Marker {\n  HUMAN,\n  BOT,\n  FREE,\n}\n\nfunction markerToStr(marker: Marker): string {\n  if (marker === Marker.HUMAN) {\n    return 'üëç';\n  } else if (marker === Marker.BOT) {\n    return 'ü§ñ';\n  } else {\n    return '';\n  }\n}\n\nfunction getMarker(isHuman: boolean): Marker {\n  return isHuman ? Marker.HUMAN : Marker.BOT;\n}\n\nfunction otherPlayer(marker: Marker): Marker {\n  return marker === Marker.HUMAN ? Marker.BOT : Marker.HUMAN;\n}\n\ninterface SquareContent {\n  marker: Marker;\n  isValidMove: boolean;\n  wouldBeFlipped: boolean;\n}\n\nfunction createBoardArray(width: number, height: number, nextPlayer: Marker): SquareContent[][] {\n  const ret: SquareContent[][] = [];\n  for (let j = 0; j < height; ++j) {\n    const row = [];\n    for (let i = 0; i < width; ++i) {\n      row.push({\n        marker: Marker.FREE,\n        isValidMove: false,\n        wouldBeFlipped: false,\n      });\n    }\n    ret.push(row);\n  }\n  const halfWidth = Math.floor(width / 2);\n  const halfHeight = Math.floor(height / 2);\n  ret[halfHeight][halfWidth].marker = Marker.BOT;\n  ret[halfHeight][halfWidth - 1].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth].marker = Marker.HUMAN;\n  ret[halfHeight - 1][halfWidth - 1].marker = Marker.BOT;\n  getValidMoves(ret, nextPlayer).forEach((_v, k) => {\n    const [x, y] = k.split(',');\n    ret[Number(y)][Number(x)].isValidMove = true;\n  });\n  return ret;\n}\n\nfunction modifySquareContents(\n  board: SquareContent[][],\n  modifier: (target: SquareContent, i: number, j: number) => void,\n) {\n  for (let j = 0; j < board.length; ++j) {\n    for (let i = 0; i < board[j].length; ++i) {\n      modifier(board[j][i], i, j);\n    }\n  }\n}\n\nfunction flippableInDirection(\n  board: SquareContent[][],\n  x: number,\n  y: number,\n  i: number,\n  j: number,\n  player: Marker,\n): [number, number][] {\n  const flippable: [number, number][] = [];\n  while (true) {\n    x += i;\n    y += j;\n    if (x < 0 || x >= board[0].length || y < 0 || y >= board.length) {\n      return [];\n    }\n    if (board[y][x].marker === Marker.FREE) {\n      return [];\n    } else if (board[y][x].marker === player) {\n      return flippable;\n    } else {\n      flippable.push([x, y]);\n    }\n  }\n}\n\nfunction flippablePositions(board: SquareContent[][], x: number, y: number, player: Marker): [number, number][] {\n  if (board[y][x].marker !== Marker.FREE) {\n    return [];\n  }\n  let flippable: [number, number][] = [];\n  for (let i = -1; i <= 1; ++i) {\n    for (let j = -1; j <= 1; ++j) {\n      flippable = flippable.concat(flippableInDirection(board, x, y, i, j, player));\n    }\n  }\n  return flippable;\n}\n\nfunction getValidMoves(boardArray: SquareContent[][], nextPlayer: Marker): Map<string, [number, number][]> {\n  const validMoves = new Map<string, [number, number][]>();\n  modifySquareContents(boardArray, (_target, x, y) => {\n    const flippable = flippablePositions(boardArray, x, y, nextPlayer);\n    if (flippable.length > 0) {\n      validMoves.set(`${x},${y}`, flippable);\n    }\n  });\n  return validMoves;\n}\n\ninterface SquareProps {\n  value: SquareContent;\n  nextPlayer: Marker;\n  onClick: () => void;\n  handleMouseEnter: () => void;\n  handleMouseLeave: () => void;\n}\n\nfunction Square(props: SquareProps): JSX.Element {\n  const { value, nextPlayer, onClick, handleMouseEnter, handleMouseLeave } = props;\n  let cssClasses = 'square';\n  if (value.isValidMove) {\n    cssClasses += ' valid-move';\n    if (nextPlayer === Marker.HUMAN) {\n      cssClasses += ' valid-human-move';\n    } else {\n      cssClasses += ' valid-bot-move';\n    }\n  }\n  if (value.wouldBeFlipped) {\n    cssClasses += ' would-be-flipped';\n    if (nextPlayer === Marker.HUMAN) {\n      cssClasses += ' would-be-flipped-human';\n    } else {\n      cssClasses += ' would-be-flipped-bot';\n    }\n  }\n  return (\n    <td className={cssClasses} onClick={onClick} onMouseEnter={handleMouseEnter} onMouseLeave={handleMouseLeave}>\n      {markerToStr(value.marker)}\n    </td>\n  );\n}\n\ninterface BoardProps {\n  boardWidth: number;\n  boardHeight: number;\n  nextPlayer: Marker;\n  flipped: (numFlipped: number) => void;\n  isGameOver: boolean;\n  gameIsOver: () => void;\n  otherPlayersTurn: () => void;\n}\n\nfunction Board(props: BoardProps): JSX.Element {\n  const { boardWidth, boardHeight, nextPlayer, flipped, isGameOver, gameIsOver, otherPlayersTurn } = props;\n  const [boardArray, setBoardArray] = useState(createBoardArray(boardWidth, boardHeight, nextPlayer));\n  const [validMoves, setValidMoves] = useState(getValidMoves(boardArray, nextPlayer));\n\n  const handleBoardClick = (x: number, y: number) => {\n    // If the game is over, no more moves can be made.\n    if (isGameOver) {\n      return;\n    }\n\n    // If the clicked square is an invalid move, we do nothing.\n    const currentKey = `${x},${y}`;\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n\n    // Since the move is valid, we save it and flip the appropriate pieces.\n    const boardArrayClone = boardArray.slice();\n    boardArrayClone[y][x].marker = nextPlayer;\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      boardArrayClone[j][i].marker = nextPlayer;\n    }\n    flipped(validMoves.get(currentKey)?.length || 0);\n\n    // Get the valid moves for the other player. If there are none, then the\n    // current player gets another turn. If the current player has none either,\n    // then the game is over.\n    let newValidMoves = getValidMoves(boardArrayClone, otherPlayer(nextPlayer));\n    if (newValidMoves.size === 0) {\n      newValidMoves = getValidMoves(boardArrayClone, nextPlayer);\n      if (newValidMoves.size === 0) {\n        gameIsOver();\n      }\n    } else {\n      otherPlayersTurn();\n    }\n\n    // Reset the valid moves marked on the board.\n    modifySquareContents(boardArrayClone, (target, x, y) => {\n      target.isValidMove = newValidMoves.has(`${x},${y}`);\n      target.wouldBeFlipped = false;\n    });\n\n    // Persist the board changes and the new set of valid moves.\n    setBoardArray(boardArrayClone);\n    setValidMoves(newValidMoves);\n  };\n\n  const handleHover = (x: number, y: number, isEnter: boolean) => {\n    const currentKey = `${x},${y}`;\n    if (!validMoves.has(currentKey)) {\n      return;\n    }\n    const boardArrayClone = boardArray.slice();\n    for (const [i, j] of validMoves.get(currentKey) || []) {\n      boardArrayClone[j][i].wouldBeFlipped = isEnter;\n    }\n    setBoardArray(boardArrayClone);\n  };\n\n  return (\n    <div>\n      <table>\n        <tbody>\n          {boardArray.map((row, y) => (\n            <tr key={y} className=\"board-row\">\n              {row.map((sc, x) => (\n                <Square\n                  key={`${x} ${y}`}\n                  value={sc}\n                  nextPlayer={nextPlayer}\n                  onClick={() => handleBoardClick(x, y)}\n                  handleMouseEnter={() => handleHover(x, y, true)}\n                  handleMouseLeave={() => handleHover(x, y, false)}\n                />\n              ))}\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  );\n}\n\nfunction Game(): JSX.Element {\n  const BOARD_HEIGHT = 8;\n  const BOARD_WIDTH = 8;\n  const [isHumanNext, setIsHumanNext] = useState(true);\n  const nextPlayer = getMarker(isHumanNext);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [score, setScore] = useState([2, 2]);\n\n  function flipped(numFlipped: number): void {\n    const newScore = score.slice();\n    if (isHumanNext) {\n      newScore[0] += 1 + numFlipped;\n      newScore[1] -= numFlipped;\n    } else {\n      newScore[0] -= numFlipped;\n      newScore[1] += 1 + numFlipped;\n    }\n    setScore(newScore);\n  }\n\n  return (\n    <div className=\"game\">\n      <div className=\"status\">{isGameOver ? 'Game over.\\n' : `Next player: ${markerToStr(nextPlayer)}\\n`}</div>\n      <div className=\"score\">{`The score is ${score[0]} for ${markerToStr(Marker.HUMAN)} and ${\n        score[1]\n      } for ${markerToStr(Marker.BOT)}.`}</div>\n      <div className=\"game-board\">\n        <Board\n          boardWidth={BOARD_WIDTH}\n          boardHeight={BOARD_HEIGHT}\n          nextPlayer={nextPlayer}\n          isGameOver={isGameOver}\n          gameIsOver={() => setIsGameOver(true)}\n          otherPlayersTurn={() => setIsHumanNext(!isHumanNext)}\n          flipped={flipped}\n        />\n      </div>\n    </div>\n  );\n}\n\n// ========================================\n\nReactDOM.render(<Game />, document.getElementById('root'));\n"],"sourceRoot":""}